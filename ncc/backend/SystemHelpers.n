using Nemerle.IO;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using System.Linq;

using DN = dnlib.DotNet;
using SR  = System.Reflection;
using SRC = System.Runtime.CompilerServices;

namespace Nemerle.Compiler
{
  public module SystemHelpers
  {
    internal IsDefined(this type : DN.TypeDef, attribute : DN.ITypeDefOrRef) : bool
    {
      foreach (a in type.CustomAttributes)
        when (DN.TypeEqualityComparer.Instance.Equals(attribute, a.AttributeType))
          return true;
      false
    }

    internal GetSystemType(typeInfo : TypeInfo) : DN.TypeDef
    {
      match (typeInfo)
      {
        | x is ExternalTypeInfo => x.SystemType
        | x is ITypeBuilder     => x.SystemType
        | _ => assert(false)
      }
    }

    internal GetSystemMemberInfo(member : IMember) : SR.MemberInfo
    {
      (member :> IBackendMember).GetHandle()
    }
    
    public GetNonVoidSystemType(type : TypeVar, systemObjectType : DN.TypeDef) : DN.IType
    {
      match (type)
      {
        | FixedType.Void => systemObjectType
        | _ => GetSystemType(type)
      }
    }

    public GetSystemType(type : TypeVar) : DN.IType
    {
      GetSystemType(type.Fix())
    }
    
    public GetSystemType(type : FixedType) : DN.IType
    {
      GetSystemType(type, ManagerClass.Instance.SystemTypeCache)
    }
    
    public GetSystemType(type : FixedType, systemTypeCache : SystemTypeClass) : DN.IType
    {
      match (type)
      {
        | Void                  => systemTypeCache.Void
        | Tuple                 => GetSystemType(TupleType.Make(type), systemTypeCache)
        | Fun                   => GetSystemType(FunctionType.Make(type), systemTypeCache)
        | StaticTypeVarRef(tv)  =>
          def genericParam = tv.GetSystemType();
          if (genericParam.DeclaringMethod != null)
            DN.GenericMVar(genericParam.Number, genericParam.DeclaringMethod)
          else
            DN.GenericVar(genericParam.Number, genericParam.DeclaringType)

        | Class(ti, [])         => GetSystemType(ti)
        | Class(ti, args)       =>
          def     tconstructor = GetSystemType(ti);
          def     typedargs    = array(args.Length);
          mutable idx          = 0;
          mutable formals      = ti.TypePparms;
          def     errorCount   = Message.ErrorCount;

          foreach (arg in args)
          {
            match (formals)
            {
              | f :: fs =>
                formals = fs;
                f.CheckConstraints(arg, type);

              | [] => Util.ice()
            }

            typedargs[idx] = ToTypeSig(GetSystemType(arg));
            ++idx;
          }

          if (errorCount == Message.ErrorCount)
            DN.GenericInstSig(if (tconstructor.IsValueType) DN.ValueTypeSig(tconstructor) else DN.ClassSig(tconstructor), typedargs);
          else
            systemTypeCache.Object

        | Ref(t) | Out(t)      => DN.Extensions.ToByRefSig(ToTypeSig(GetSystemType(t)))
        | Array(et, rank)      =>
          def et_SystemType = GetSystemType(et);
          when (et_SystemType.Equals(systemTypeCache.Void))
            Message.FatalError("array element type cannot be void");
          if (rank == 1)
            DN.SZArraySig(ToTypeSig(et_SystemType))
          else
            DN.ArraySig(ToTypeSig(et_SystemType), rank)

        | Intersection(types)   => Message.FatalError($"The intersection of types has detect. Please, specify type manually. Intersected types: ..$(types)");
      }
    }

    private ToTypeSig(type : DN.IType) : DN.TypeSig
    {
      | typeSig is DN.TypeSig       => typeSig
      | argType is DN.ITypeDefOrRef => DN.Extensions.ToTypeSig(argType, true)
      | _ => assert(false)
    }
  }
} // end ns
