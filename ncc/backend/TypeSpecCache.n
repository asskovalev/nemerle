using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;

using DN = dnlib.DotNet;
using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{
  internal class TypeSpecCache : SCG.Dictionary[array[DN.TypeSig], GenericTypeSpec]
  {
    new private sealed class Comparer : SCG.IEqualityComparer[array[DN.TypeSig]]
    {
      public static Instance : Comparer = Comparer();

      public GetHashCode(obj : array[DN.TypeSig]) : int
      {
        def comparer = DN.SigComparer(0 :> DN.SigComparerOptions);
        mutable hash = obj.Length;
        foreach (sig in obj)
          unchecked hash ^= comparer.GetHashCode(sig);
        hash
      }

      public Equals(a : array[DN.TypeSig], b : array[DN.TypeSig]) : bool
      {
        | (null, null) => true
        | (null, _) | (_, null) | _ when a.Length != b.Length => false
        | _ =>
          def comparer = DN.SigComparer(0 :> DN.SigComparerOptions);
          for (mutable i = 0; i < a.Length; ++i)
          {
            unless (comparer.Equals(a[i], b[i]))
              return false;
          }
          true
      }
    }

    private _owner : TypeInfo;

    public this(owner : TypeInfo)
    {
      base(Comparer.Instance);
      _owner = owner;
    }

    public GetTypeSpec(specialization : FixedType.Class) : IBackendType
    {
      assert(specialization.tycon : object == _owner);

      def     typedargs    = array(specialization.args.Length);
      assert(typedargs.Length > 0);

      mutable idx          = 0;
      mutable formals      = _owner.TypePparms;
      def     errorCount   = Message.ErrorCount;

      foreach (arg in specialization.args)
      {
        match (formals)
        {
          | f :: fs =>
            formals = fs;
            f.CheckConstraints(arg, specialization);

          | [] => Util.ice()
        }

        typedargs[idx] = SystemHelpers.ToTypeSig(arg);
        ++idx;
      }

      if (errorCount == Message.ErrorCount)
      {
        mutable typeSpec;
        unless (TryGetValue(typedargs, out typeSpec))
        {
          typeSpec = GenericTypeSpec(_owner, typedargs);
          Add(typedargs, typeSpec);
        }
        typeSpec
      }
      else
        _owner.InternalType.Object :> IBackendType;
    }
  }
} // end ns
