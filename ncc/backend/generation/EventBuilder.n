using Nemerle.Compiler.Backend;
using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Utility;

using System.Reflection;
using System.IO;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;
using System.Security;

using DN = dnlib.DotNet;
using NC = Nemerle.Compiler;

namespace Nemerle.Compiler
{
  public partial class EventBuilder
  {
    internal mutable event_builder : DN.EventDef;

    GetHandle() : DN.IMemberDef implements IBackendMember.GetHandle
    {
      assert(event_builder != null, Name);
      event_builder
    }

    /// Adds an event builder
    internal override CreateEmitBuilder(tb : DN.TypeDef) : void
    {
      def ty = this.GetMemType().GetSystemType();
      event_builder = tb.DefineEvent(Name, EventAttributes.None, ty);
    }

    internal override Compile () : void
    {
      base.Compile ();
      unless (modifiers.IsEmpty) {
        modifiers.SaveCustomAttributes (declaring_type, fun (target, a, shouldEmit) {
          if (target %&& System.AttributeTargets.Event) {
            when(shouldEmit)
              event_builder.SetCustomAttribute (a);
            null
          }
          else "event " + ToString ()
        });
      }

      event_builder.SetAddOnMethod(adder.GetMethodBuilder());
      event_builder.SetRemoveOnMethod(remover.GetMethodBuilder());
    }
  }
}
