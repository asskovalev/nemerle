using Nemerle.Compiler.Backend;
using Nemerle.Collections;
using Nemerle.Surround;
using Nemerle.Utility;

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Diagnostics.SymbolStore;

using Nemerle.Compiler.Typedtree;
using Nemerle.Logging;

using dnlib.DotNet.Emit;

using SCG = System.Collections.Generic;
using DN = dnlib.DotNet;

namespace Nemerle.Compiler
{
  [assembly: LogFlag (EMIT, 0)]
  [assembly: DefineSurround("inScope", false, _ilg.BeginScope(), _ilg.EndScope())]


  /* ----------------------------------------------------------------------- */
  /* -- CODE GENERATOR CLASS ----------------------------------------------- */
  /* ----------------------------------------------------------------------- */

  /**
   * Generates the IL code for a method or a constructor
   */
  [ManagerAccess]
  class ILEmitter
  {
    private _module_builder             : DN.ModuleDef;
    private _ilg                        : NemerleGenerator;
    private _parent_type_builder        : TypeBuilder;
    private mutable _importer           : DN.Importer;
    private _this_is_value_type         : bool;
    private _type_of_this               : DN.TypeSig;
    private _method_name                : string;
    private _method_builder             : MethodBuilder;
    private _methodDef                  : DN.MethodDef;
    private mutable _method_start_label : Label;
    private mutable _debug_doc          : ISymbolDocumentWriter;
    private mutable _is_ctor            : bool;
    private mutable _is_lambda          : bool;
    private _labels                     : Hashtable [int, Label] = Hashtable ();
    private _label_usage                : Hashtable [int, TExpr] = Hashtable ();

    private static _primitiveTypeArrayOpcodes : Hashtable[DN.UTF8String, OpCode * OpCode * OpCode] = Hashtable();

    static this()
    {
      _primitiveTypeArrayOpcodes["SByte"]   = (OpCodes.Stelem_I1, OpCodes.Ldelem_I1, OpCodes.Ldind_I1);
      _primitiveTypeArrayOpcodes["Byte"]    = (OpCodes.Stelem_I1, OpCodes.Ldelem_U1, OpCodes.Ldind_U1);
      _primitiveTypeArrayOpcodes["Boolean"] = (OpCodes.Stelem_I1, OpCodes.Ldelem_I1, OpCodes.Ldind_I1);
      _primitiveTypeArrayOpcodes["Char"]    = (OpCodes.Stelem_I2, OpCodes.Ldelem_I2, OpCodes.Ldind_I2);
      _primitiveTypeArrayOpcodes["Int16"]   = (OpCodes.Stelem_I2, OpCodes.Ldelem_I2, OpCodes.Ldind_I2);
      _primitiveTypeArrayOpcodes["UInt16"]  = (OpCodes.Stelem_I2, OpCodes.Ldelem_U2, OpCodes.Ldind_U2);
      _primitiveTypeArrayOpcodes["Int32"]   = (OpCodes.Stelem_I4, OpCodes.Ldelem_I4, OpCodes.Ldind_I4);
      _primitiveTypeArrayOpcodes["UInt32"]  = (OpCodes.Stelem_I4, OpCodes.Ldelem_U4, OpCodes.Ldind_U4);
      _primitiveTypeArrayOpcodes["Int64"]   = (OpCodes.Stelem_I8, OpCodes.Ldelem_I8, OpCodes.Ldind_I8);
      _primitiveTypeArrayOpcodes["UInt64"]  = (OpCodes.Stelem_I8, OpCodes.Ldelem_I8, OpCodes.Ldind_I8);
      _primitiveTypeArrayOpcodes["Single"]  = (OpCodes.Stelem_R4, OpCodes.Ldelem_R4, OpCodes.Ldind_R4);
      _primitiveTypeArrayOpcodes["Double"]  = (OpCodes.Stelem_R8, OpCodes.Ldelem_R8, OpCodes.Ldind_R8);
      _primitiveTypeArrayOpcodes["IntPtr"]  = (OpCodes.Stelem_I,  OpCodes.Ldelem_I,  OpCodes.Ldind_I);
      _primitiveTypeArrayOpcodes["UIntPtr"] = (OpCodes.Stelem_I,  OpCodes.Ldelem_I,  OpCodes.Ldind_I);
    }

    /**
     * Creates and executes a code generator for a method
     */
    internal this (method_builder : MethodBuilder)
    {
      Manager              = method_builder.Manager;
      _module_builder      = Manager.Hierarchy._module_builder;
      _method_builder      = method_builder;
      _methodDef           = (_method_builder : IBackendMethod).GetMethodInfo();
      _importer            = DN.Importer(_module_builder, DN.ImporterOptions.TryToUseDefs, DN.GenericParamContext(_methodDef.DeclaringType, _methodDef));
      _ilg                 = NemerleGenerator();
      _parent_type_builder = _method_builder.DeclaringType;
      _method_name         = _methodDef.DeclaringType.FullName + "::" + _methodDef.Name;
      _this_is_value_type  = _parent_type_builder.IsValueType;
      _type_of_this        = SystemHelpers.GetSystemType(_parent_type_builder.GetMemType(), ref _importer);
    }

    public Run () : void
    {
      _ilg.SetDocument (_debug_doc);

      _method_start_label = _ilg.DefineLabel ();
      _ilg.MarkLabel (_method_start_label);

      mutable debugBody;
      
      match (_method_builder.GetHeader ().body)
      {
        | FunBody.Typed(body) =>
          debugBody = body;
          
          _is_ctor   = is_ctor(_method_builder);
          _is_lambda = _method_builder.DeclaringType.is_lambda;

          surroundwith(inScope)
          {
            emit (body);

            if (body.Throws)
            {
              //method end is unreachable, but fall through end of method can be
              //detected by the runtime, fix it (bug #1091)
              def l = _ilg.DefineLabel ();
              _ilg.MarkLabel (l);
              _ilg.Emit (OpCodes.Br, l);
            }
            else _ilg.Emit (OpCodes.Ret);
          }

          // let GC take it
          _method_builder.GetHeader ().body = FunBody.ILed ();
        | _ => Util.ice ($"method $_method_name is already ILed")
      }
      
      foreach ((id, v) in _label_usage.KeyValuePairs)
      {
        when (v != null) // shouldn't happen now
        {
          Message.Error (v.Location, $"non local goto (block return?) detected (l$id)");
        }
      }

      _methodDef.Body = _ilg.CreateBody();
    }

    private static is_always_true (expr : TExpr) : bool
    {
      | Literal (Literal.Bool (true)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_true  = is_always_true  (then_expr);
        def else_always_true  = is_always_true  (else_expr);
        
        cond_always_true && then_always_true ||
        cond_always_false && else_always_true
        // unsafe, cond can have side effects
        // then_always_true && else_always_true

      | _ => false
    }

    [Nemerle.Memoize(Scope=Instance, Synchronized=true)]
    private DefineDebugDocument (fileIndex : int) : ISymbolDocumentWriter
    {
      if (fileIndex != 0) // not Location.Default
        _module_builder.DefineDocument (Path.GetFullPath (Location.GetFileName(fileIndex)), 
          SymDocumentType.Text, SymLanguageType.ILAssembly, SymLanguageVendor.Microsoft);
      else {
        Message.Warning ("missing debug location, this is probably some internal compiler error"); 
        def loc = LocationStack.Top();
        if (loc != Location.Default)
          DefineDebugDocument (loc.FileIndex);
        else
          _debug_doc;
      }
    }

    public SetDocument (loc : Location) : void
    {
      _debug_doc = DefineDebugDocument(loc.FileIndex);
    }

    private static is_always_false (expr : TExpr) : bool
    {
      | Literal (Bool (false)) => true

      | If (cond_expr, then_expr, else_expr, _, _) =>
        def cond_always_true  = is_always_true  (cond_expr);
        def cond_always_false = is_always_false (cond_expr);
        def then_always_false = is_always_false (then_expr);
        def else_always_false = is_always_false (else_expr);

        cond_always_true && then_always_false ||
        cond_always_false && else_always_false
        // unsafe, cond can have side effects
        // then_always_false && else_always_false
        
      | _ => false
    }

    IsDebugEnabled : bool { get { _debug_doc != null } }


    /** Emit volatile prefix if needed. */
    private maybe_volatile (expr : TExpr) : void
    {
      | StaticRef (_, f is IField, _)
      | FieldMember (_, f) =>
        when (f.IsVolatile)
          _ilg.Emit (OpCodes.Volatile)
      | _ => ()
    }


    /** Box the value of type [t] if needed.  */
    need_reference (t : DN.TypeSig) : void
    {
      when (t.IsValueType || t.IsGenericParameter)
        _ilg.Emit (OpCodes.Box, t);
    }


    is_void (ty : TypeVar) : bool
    {
      ty.Fix () : object == InternalType.Void
    }


    static is_ctor (meth : IMethod) : bool
    {
      meth.MemberKind == MemberKinds.Constructor
    }


    GetMethodInfo(from_type : TypeVar, meth : IMethod, typars : list [TypeVar]) : DN.IMethod
    {
      def methodDef = (meth :> IBackendMethod).GetMethodInfo();
      def from_type = from_type.Fix ().GetInstantiatedSuperType (meth.DeclaringType);
      def system_from_type = from_type.GetSystemType(ref _importer);

      mutable methodRef =
        if (system_from_type is DN.GenericInstSig)
          DN.MemberRefUser(_module_builder, methodDef.Name, _importer.Import(methodDef.MethodSig), DN.TypeSpecUser(system_from_type))
        else
          _importer.Import(methodDef);

      def m_typarms = meth.GetHeader().TypeParameters;
      unless (m_typarms.IsEmpty)
      {
        def errorCount = Message.ErrorCount;
        NList.Iter2 (m_typarms, typars, _.CheckConstraints (_, meth));
        when (errorCount == Message.ErrorCount)
        {
          def pars  = typars.MapToArray(SystemHelpers.GetNonVoidSystemType(_, SystemTypeCache.Object, ref _importer));
          methodRef = DN.MethodSpecUser(methodRef :> DN.IMethodDefOrRef, DN.GenericInstMethodSig(pars));
        }
      }
      methodRef
    }

    GetFieldInfo (_obj : TExpr, fld : IField) : DN.IField
    {
      def obj_type = _obj.FixedType().GetInstantiatedSuperType (fld.DeclaringType).GetSystemType (ref _importer);
      GetFieldInfo (obj_type, fld);
    }

    GetFieldInfo(from_type : DN.TypeSig, field : IField) : DN.IField
    {
      def fieldDef = (field :> IBackendField).GetFieldInfo();
      if (from_type is DN.GenericInstSig)
      {
        def fieldRef = DN.MemberRefUser(_module_builder, fieldDef.Name, _importer.Import(fieldDef.FieldSig));
        fieldRef.Class = DN.TypeSpecUser(from_type);
        fieldRef
      }
      else
        _importer.Import(fieldDef)
    }

    store_local (decl : LocalValue) : void
    {
      if (decl.IsParm) {
        Util.cassert (! decl.IsByRefParm);
        store_argument (decl.ParmIndex)
      } else
        // simply skip assignment here
        unless (is_void (decl.Type))
          _ilg.Emit (OpCodes.Stloc, decl.LocalSlot);
    }


    emit_parms (parms : list [Param]) : void
    {
      emit_exprs (parms.Map (_.expr));
    }

    static skipped (expr : TExpr) : void
    {
      | TExpr.Goto
      | TExpr.Literal (Literal.Void)
      | TExpr.Label (_, Literal (Void))
      | TExpr.DebugInfo (Literal (Void), null)
      | TExpr.DebugInfo (null, _) => ()
      | _ =>
        Message.Warning (expr.Location,
                         "this expression has been skipped in code "
                         "generation because of unreachable code");
        //Message.Warning (expr.loc, expr.ToString ());
    }

    static no_cast_needed (src_type : DN.TypeSig, target_type : DN.TypeSig) : bool
    {
      DN.TypeEqualityComparer.Instance.Equals(src_type, target_type)
    }


    static make_ref_type (t : DN.TypeSig) : DN.TypeSig
    {
      DN.ByRefSig(t)
    }

    private emit_tuple_function_conversion (after : FixedType, member_from : FixedType, member : IMember) : void
    {
      def interesting_part (t) {
        if (member is IMethod)
          match (t.Fix ()) {
            | FixedType.Fun (_, t) => t
            | _ => Util.ice ()
          }
        else t
      }

      def is_single_arg_function (t) {
        match (interesting_part (t).Fix ()) {
          | Fun (from, _) => ! (from.Fix () is FixedType.Tuple)
          | _ => false
        }
      }

      match (member_from) {
        | Class | Array | StaticTypeVarRef =>
          match (after) {
            | Fun (from, to) =>
              match (from.Fix ()) {
                | Tuple (parms) =>

                  // I think there is one more case
                  // class A[T] { x : T; }
                  // B[T] : A[T->void]
                  // C[T] : B[T*T]
                  // but this is really perverse

                  when (is_single_arg_function (member.GetMemType ()) ||
                        is_single_arg_function (member_from.TypeOfMember (member))) {

                    def ftn = InternalType.GetFunctionType (parms.Length);
                    def info =
                      if (to.Fix () is FixedType.Void) {
                        def mt = FixedType.Class (ftn.FromTupleVoidTyCon, parms);
                        GetMethodInfo(mt, ftn.FromTupleVoidCtor, [])
                      } else {
                        def mt = FixedType.Class (ftn.FromTupleTyCon, parms + [to]);
                        GetMethodInfo(mt, ftn.FromTupleCtor, [])
                      }
                    // Message.Warning ($ "using f1->fN conversion");
                    _ilg.Emit (OpCodes.Newobj, info)
                  }

                | _ => {}
              }
            | _ => {}
          }
        | _ => {}
      }
    }

    /// If stack contains 1 it plase and on the contrary
    private InversBool() : void
    {
      _ilg.Emit(OpCodes.Ldc_I4_0); _ilg.Emit(OpCodes.Ceq);
    }

    /**
     * Emits an expression.
     */
    private emit (expr : TExpr) : void
    {
      log (EMIT, $"{ emit: $expr");
      Util.cassert (expr != null);
      Util.locate (expr.Location,
      match (expr)
      {
        /* -- SEQUENCING --------------------------------------------------- */

        /* emits a sequence of expressions */
        | Sequence (e1, e2) =>
          emit (e1);
          if (!e1.Throws || e2.JumpTarget)
            emit (e2);
          else
            skipped (e2);

        | DefValIn (_, let_val, body) when let_val.Throws && ! body.JumpTarget =>
          emit (let_val);
          skipped (body);
        
        | DefValIn(decl, TExpr.Literal, TExpr.Literal(Literal.Void())) when !decl.EverUsed && !decl.InClosure => () // ignore debug literals
        | DefValIn(decl, let_val, let_in) => // emits a local value definition

          match (let_val) {
            | DefaultValue when !decl.IsMutable =>
              unless (is_void (decl.Type))
                declare_val_local_slot_ex (decl);

            | ImplicitValueTypeCtor =>
              def slot = declare_val_local_slot (decl);
              _ilg.Emit (OpCodes.Ldloca, slot);
              _ilg.Emit (OpCodes.Initobj, let_val.GetSystemType (ref _importer));

            | _ =>
              emit (let_val);
              unless (is_void (decl.Type)) {
                if (!decl.EverUsed) {
                  _ilg.Emit (OpCodes.Pop);
                } else {
                  def local_slot = declare_val_local_slot(decl);
                  unless (let_val.Throws)
                    _ilg.Emit (OpCodes.Stloc, local_slot);
                }
              }
          }

          emit (let_in);


        /* -- CONDITIONAL CONSTRUCTIONS ------------------------------------ */

        /* emits the if/then/else construction */
        | If (cond_expr, then_expr, else_expr, then_debug_loc, else_debug_loc) =>

          def emit_debug (loc) {
            // This code locates the debugger right after the condition gets successful or fails.
            // Used to debug match cases.
            //
            when (IsDebugEnabled && loc.IsSourceAvailable)
              emit_debug_info (TExpr.DebugInfo (loc, null, null, null));
          }

          def emit_branch (expr : TExpr, else_label : Label, debug_loc: Location) {

            def emit_br (opcode1, opcode2)
            {
              if (!IsDebugEnabled || !debug_loc.IsSourceAvailable) {
                _ilg.Emit (opcode1, else_label);
              } else {
                def debug_label = _ilg.DefineLabel ();
                _ilg.Emit (opcode2, debug_label);
                emit_debug (debug_loc);
                _ilg.Emit (OpCodes.Br, else_label);
                _ilg.MarkLabel (debug_label);
              }
            }

            match (expr) {
              | Call (OpCode ("=="), [nested_cond,
                Param where (expr = TExpr.TypeConversion(TExpr.Literal(Literal.Bool(true)), _, _, _))], _) =>
                emit_branch(nested_cond.expr, else_label, Location.Default)

              | Call (OpCode (opcode), parms, _) =>
                emit_parms (parms);

                /* NOTE: the opcodes are swapped so that the 'then' expression
                         can be emitted before the 'else' expression */
                def opcodes =
                  match (opcode)
                  {
                    | "==.ref" | "=="   => (OpCodes.Bne_Un, OpCodes.Beq)
                    | "!=.ref" | "!="   => (OpCodes.Beq,    OpCodes.Bne_Un)
                    | "<.s"    | "<.f"  => (OpCodes.Bge,    OpCodes.Blt)
                    | "<.u"             => (OpCodes.Bge_Un, OpCodes.Blt_Un)
                    | ">.s"    | ">.f"  => (OpCodes.Ble,    OpCodes.Bgt)
                    | ">.u"             => (OpCodes.Ble_Un, OpCodes.Bgt_Un)
                    | "<=.s"   | "<=.f" => (OpCodes.Bgt,    OpCodes.Ble)
                    | "<=.u"            => (OpCodes.Bgt_Un, OpCodes.Ble_Un)
                    | ">=.s"   | ">=.f" => (OpCodes.Blt,    OpCodes.Bge)
                    | ">=.u"            => (OpCodes.Blt_Un, OpCodes.Bge_Un)
                    | "bool.!"          => (OpCodes.Brtrue, OpCodes.Brfalse)
                    | _ => Util.ice ("invalid opcode '" + opcode +
                                     "' in optimized TExpr.If pattern")
                  };

                emit_br (opcodes);

              | HasType (val, ty) =>
                emit (val);
                need_reference (val.GetSystemType (ref _importer));
                _ilg.Emit (OpCodes.Isinst, ty.GetSystemType (ref _importer));
                emit_br (OpCodes.Brfalse, OpCodes.Brtrue);

              | If (new_cond, new_then, new_else, _, _) =>
                def my_label_else = _ilg.DefineLabel ();
                def my_label_fi = _ilg.DefineLabel ();
                emit_branch (new_cond, my_label_else, Location.Default);
                emit_branch (new_then, else_label, Location.Default);
                unless (new_then.Throws)
                  _ilg.Emit (OpCodes.Br, my_label_fi);
                _ilg.MarkLabel (my_label_else);
                emit_branch (new_else, else_label, Location.Default);
                _ilg.MarkLabel (my_label_fi);

              | e when is_always_true (e) => ()
              | e when is_always_false (e) =>
                _ilg.Emit (OpCodes.Br, else_label);

              | _ =>
                //Message.Debug (e.loc, pretty_print (e));
                // most of other expressions here are TExpr.Ref
                emit (expr);

                unless (expr.Throws)
                  emit_br (OpCodes.Brfalse, OpCodes.Brtrue);
            }
          }

          def label_condition_else = _ilg.DefineLabel ();
          def label_condition_fi   = _ilg.DefineLabel ();

          surroundwith(inScope)
          {
            emit_branch (cond_expr, label_condition_else, else_debug_loc);

            surroundwith(inScope)
            {
              emit_debug (then_debug_loc);
              emit (then_expr);
            }

            unless (then_expr.Throws)
              _ilg.Emit (OpCodes.Br, label_condition_fi);

            surroundwith(inScope)
            {
              _ilg.MarkLabel (label_condition_else);
              emit (else_expr);
            }

            _ilg.MarkLabel (label_condition_fi);
          }


        /* emit a type check construction */
        | HasType (expr, ty) =>
          emit (expr);
          def label_condition_not_null = _ilg.DefineLabel ();
          def label_condition_has_type = _ilg.DefineLabel ();
          def label_condition_continue = _ilg.DefineLabel ();

          _ilg.Emit (OpCodes.Dup);
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_not_null);

          def ctor = _importer.Import(SystemTypeCache.NullMatchException.GetMethod(".ctor"));
          _ilg.Emit(OpCodes.Newobj, ctor);
          _ilg.Emit(OpCodes.Throw);

          _ilg.MarkLabel (label_condition_not_null);

          need_reference (expr.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Isinst, ty.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Brtrue_S, label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_0);
          _ilg.Emit (OpCodes.Br_S, label_condition_continue);
          _ilg.MarkLabel (label_condition_has_type);
          _ilg.Emit (OpCodes.Ldc_I4_1);
          _ilg.MarkLabel (label_condition_continue);

          
        | DefaultValue =>
          match(expr.GetSystemType (ref _importer)) {
            | _ when is_void(expr.FixedType()) => ()
            | ty when ty.Equals (SystemTypeCache.Char)
            | ty when ty.Equals (SystemTypeCache.Byte)
            | ty when ty.Equals (SystemTypeCache.SByte)
            | ty when ty.Equals (SystemTypeCache.Int16)
            | ty when ty.Equals (SystemTypeCache.Int32)
            | ty when ty.Equals (SystemTypeCache.UInt16)
            | ty when ty.Equals (SystemTypeCache.UInt32)
            | ty when ty.Equals (SystemTypeCache.Boolean) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
            | ty when ty.Equals (SystemTypeCache.Int64)
            | ty when ty.Equals (SystemTypeCache.UInt64) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Conv_I8);
            | ty when ty.Equals (SystemTypeCache.Single) =>
              _ilg.Emit (OpCodes.Ldc_R4, 0.0f);
            | ty when ty.Equals (SystemTypeCache.Double) =>
              _ilg.Emit (OpCodes.Ldc_R8, 0.0d);
            | ty when ty.Equals (SystemTypeCache.Decimal) =>
              _ilg.Emit (OpCodes.Ldc_I4_0);
              _ilg.Emit (OpCodes.Newobj, SystemTypeCache.Decimal_ctors.Get("Int32").Value);
            | ty when ty.IsValueType || ty.IsGenericParameter =>
              def local_slot = _ilg.DeclareLocal (ty);
              _ilg.Emit (OpCodes.Ldloca, local_slot);
              _ilg.Emit (OpCodes.Initobj, ty);
              _ilg.Emit (OpCodes.Ldloc, local_slot);
            | _ => _ilg.Emit (OpCodes.Ldnull);
          }
            
            
        | CtorOf(ty, method) =>
          def sysType = ty.GetSystemType(ref _importer);
          def ctorInfo = GetMethodInfo(ty, method, []);
          _ilg.Emit (OpCodes.Ldtoken, ctorInfo);
          _ilg.Emit (OpCodes.Ldtoken, sysType);
          _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle2);
          _ilg.Emit (OpCodes.Castclass, typeof(ConstructorInfo));
          
        | MethodOf(from_type, method, typars) =>
          def methodInfo = GetMethodInfo(from_type, method, typars);
          def declTy = methodInfo.DeclaringType;
          _ilg.Emit (OpCodes.Ldtoken, methodInfo);
          if (declTy == null)
            _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle);
          else
          {
            _ilg.Emit (OpCodes.Ldtoken, declTy);
            _ilg.Emit (OpCodes.Call, SystemTypeCache.MethodBase_GetMethodFromHandle2);
          }
          _ilg.Emit (OpCodes.Castclass, typeof(MethodInfo));
          
        | ClosureObjectOf(TExpr.FieldMember(obj, _))    => emit(obj);
        | ClosureFieldOf(TExpr.FieldMember(obj, field)) => emit(TExpr.FieldOf(obj.Type, field));
        | ClosureObjectOf => assert(false, "You must put into ClosureObjectOf only TExpr.LocalRef which will be closured by compiler");
        | ClosureFieldOf  => assert(false, "You must put into ClosureFieldOf only TExpr.LocalRef which will be closured by compiler");

        | FieldOf(ty, field) =>
          def fielfInfo = GetFieldInfo(ty.GetSystemType(ref _importer), field);
          def declTy = fielfInfo.DeclaringType;
          _ilg.Emit (OpCodes.Ldtoken, fielfInfo);
          if (declTy == null)
            _ilg.Emit (OpCodes.Call, SystemTypeCache.FieldInfo_GetFieldFromHandle);
          else
          {
            _ilg.Emit (OpCodes.Ldtoken, declTy);
            _ilg.Emit (OpCodes.Call, SystemTypeCache.FieldInfo_GetFieldFromHandle2);
          }
          _ilg.Emit (OpCodes.Castclass, typeof(FieldInfo));
          
        /* load runtime representation of given type */
        | TypeOf (t) =>
          _ilg.Emit (OpCodes.Ldtoken, t.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Call, SystemTypeCache.Type_GetTypeFromHandle);


        /* emits the TExpr.Switch instruction */
        | Switch (indexing_expr, default_expr, cases) =>
          match (cases) {
            | [] => Message.Warning ("empty TExpr.Switch instruction");
            | _ =>
              emit (indexing_expr);
              emit_switch (default_expr, cases)
          }


        | MacroEnvelope (_, _, expr, _) =>
          emit (expr)


        | Label(id, DefaultValue as nextExpr) when nextExpr.Type is FixedType.Void with reset_throw = true // VladD2: This is a workaround for "dead code" hack. 
                                                                                                           // The Label(_, DefaultValue) is usually generated by macros. And macros are responsible for the lack of dead code. 
        | Label(id, nextExpr) with reset_throw = false =>
          // insert label so TExpr.Goto can work
          if (_labels.Contains(id))
            _label_usage[id] = null;
          else
            _labels[id] = _ilg.DefineLabel();

          _ilg.MarkLabel(_labels[id], reset_throw);
          emit(nextExpr);


        | Goto (id, try_block) =>
          if (_labels.Contains (id))
            _label_usage[id] = null;
          else
          {
            _label_usage[id] = expr;
            _labels[id] = _ilg.DefineLabel ();
          }
          
          if (try_block == 0)
            _ilg.Emit (OpCodes.Br, _labels [id]);
          else
          {
            // Message.Warning (expr.loc, $"emit leave, id=$id");
            _ilg.Emit (OpCodes.Leave, _labels [id]);
          }


        /* -- TYPE CONVERSIONS --------------------------------------------- */


        // when expr throws we shouldn't emit anything
        | TypeConversion (expr, _, _, _) when expr.Throws => emit (expr)
        | TypeConversion(expr, target_type, _, _) when target_type.IsPointer => emit_value_to_ptr_conversion(expr, target_type);
        | TypeConversion (expr, cast_to_type, _, _) /* do not perform casts between same types */
          when no_cast_needed (expr.GetSystemType (ref _importer), cast_to_type.GetSystemType (ref _importer)) => emit (expr)
        | TypeConversion (expr, cast_to_type, ConversionKind.Boxing, _) // special case for  'a : 'b conversion
          when cast_to_type.GetSystemType (ref _importer).IsGenericParameter =>
          emit (expr);
          _ilg.Emit (OpCodes.Box, expr.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.GetSystemType (ref _importer));

        | TypeConversion (expr, cast_to_type, _, _) when cast_to_type.GetSystemType (ref _importer).IsGenericParameter =>
          emit (expr);
          when (expr.FixedType().IsValueType || expr.FixedType() is FixedType.StaticTypeVarRef)
            _ilg.Emit (OpCodes.Box, expr.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Unbox_Any, cast_to_type.GetSystemType (ref _importer));
          
        | TypeConversion (ignored, ty, _, _) when is_void (ty) =>
          // a little trickery, so emit can be tail called sometimes
          if (is_void (ignored.Type))
            emit (ignored)
          else {
            emit (ignored);
            _ilg.Emit (OpCodes.Pop);
          }
        
        /* to nonvalue type */
        | TypeConversion(expr, cast_to_type, kind, _) when !cast_to_type.Fix().IsValueType =>
          emit(expr);

          if (is_void(expr.Type))
            /* special case casts from void */
            _ilg.Emit (OpCodes.Ldnull);
          else if (expr.GetSystemType(ref _importer).IsGenericParameter)
          {
            _ilg.Emit (OpCodes.Box, expr.GetSystemType(ref _importer));

            unless (cast_to_type.Fix().IsSystemObject)
              if (cast_to_type.Fix().IsValueType)
                _ilg.Emit(OpCodes.Unbox_Any, cast_to_type.GetSystemType(ref _importer));
              else
                _ilg.Emit(OpCodes.Castclass, cast_to_type.GetSystemType(ref _importer));
          }
          else if (expr.GetSystemType(ref _importer).IsValueType)
          {
            // Message.Debug (k.ToString ());
            // box value types casted to non value types
            _ilg.Emit(OpCodes.Box, expr.GetSystemType (ref _importer));
          }
          else
          {
            // upcast / downcast non-value types
            def castToFixedType = cast_to_type.Fix();
            def cast_to_type = castToFixedType.GetSystemType(ref _importer);

            when (expr.GetSystemType(ref _importer).IsArray && cast_to_type.IsArray 
              && expr.GetSystemType(ref _importer).Next.IsValueType != cast_to_type.Next.IsValueType)
            {
              Message.Error(expr.Location, $"attempting to cast a value type array $(expr.GetSystemType (ref _importer)) to non-value type array $(cast_to_type) which cannot succeed");
            }
            
            def isUpCast = kind is ConversionKind.UpCast;

            when (!isUpCast || castToFixedType.IsInterface)
              _ilg.Emit(OpCodes.Castclass, cast_to_type);
          }

        // unbox value types or perform value type conversion
        | TypeConversion (val, cast_to_type, kind, _) =>
          def is_checked = ! (kind is IL (false));
          emit (val);
          def type_of_expr = val.GetSystemType (ref _importer);
          def cast_to_stype = cast_to_type.GetSystemType (ref _importer);

          when (type_of_expr.IsGenericParameter)
            _ilg.Emit (OpCodes.Box, type_of_expr);

          if (type_of_expr.IsValueType) {
            /* perform conversion of value types */
            emit_value_type_conversion (expr.Location, val.FixedType(), cast_to_type.Fix (), is_checked)
          }
          else if (SystemTypeCache.Object : object == type_of_expr && cast_to_stype.IsValueType) {
          	_ilg.Emit (OpCodes.Unbox_Any, cast_to_stype)
          }
          else if (type_of_expr.IsGenericParameter || 
                   SystemTypeCache.Object : object == type_of_expr || 
                   type_of_expr.IsInterface || 
                   (SystemTypeCache.Enum : object == type_of_expr && cast_to_type.IsEnum)) {
            /* unboxing returns a pointer to a value */
            _ilg.Emit (OpCodes.Unbox, cast_to_stype);

            maybe_volatile (val);

            emit_ldind_for_value_type (cast_to_stype)
          }
          else
            Util.ice($"$_method_name: failed to convert non-value type $type_of_expr to a value type $cast_to_type");

        /* -- REFERENCES --------------------------------------------------- */

        /* load the value of a local variable or a method parameter */
        | LocalRef (decl) =>
          unless (is_void (decl.Type))
            emit_ce_ref (decl, get_address_for_value_types = expr.NeedAddress)

        /* load the value of a field */
        | FieldMember (base_object, field) =>
          def result_will_be_address = expr.NeedAddress;

          if (result_will_be_address) 
            _ = emit_and_convert_to_address (base_object);
          else
            emit (base_object);

          maybe_volatile (expr);

          def field_info = GetFieldInfo (base_object, field);

          when (base_object.GetSystemType (ref _importer).IsGenericParameter)
            _ilg.Emit (OpCodes.Box, base_object.GetSystemType (ref _importer));

          if (result_will_be_address)
            _ilg.Emit(OpCodes.Ldflda, field_info);
          else
            _ilg.Emit(OpCodes.Ldfld, field_info);

          emit_tuple_function_conversion (expr.FixedType(), base_object.FixedType(), field);

        /* load the value of a static field */
        | StaticRef (t, field is IField, _) =>
          def field_info = GetFieldInfo (t.GetSystemType (ref _importer), field);
          
          assert(field.IsStatic, "GlobalRef to a non-static field");

          when (field.IsLiteral)
            // should not happen
            Message.Warning ("loading literal as field `" + field_info.ToString () + "'");

          maybe_volatile (expr);
          if (expr.NeedAddress) {
            if(field.IsMutable)
               _ilg.Emit (OpCodes.Ldsflda, field_info);
            else {
               def temp = _ilg.DeclareLocal (field.GetMemType().GetSystemType (ref _importer));
               _ilg.Emit (OpCodes.Ldsfld, field_info);
               _ilg.Emit (OpCodes.Stloc, temp);
               _ilg.Emit (OpCodes.Ldloca, temp);
            }
          }
          else
            _ilg.Emit (OpCodes.Ldsfld, field_info);

          emit_tuple_function_conversion (expr.FixedType(), t, field);

        | PointerIndexer(ptr, index) => emit_ptr_indexing(expr.NeedAddress, ptr, index);
        // load an array element
        | ArrayIndexer (array_obj, [index]) =>
          emit_exprs ([array_obj, index]);
          def element_type = array_obj.GetSystemType(ref _importer).Next;
          assert(element_type != null, "non-array in TExpr.ArrayIndexer");

          if (expr.NeedAddress)
            _ilg.Emit (OpCodes.Ldelema, element_type)
          else
            emit_array_load_opcode (element_type);
          

        | ArrayIndexer (array_obj, indexes) =>
          emit_exprs ([array_obj] + indexes);
          def method =
            if (expr.NeedAddress) array_addr_method (array_obj)
            else array_get_method (array_obj);
          emit_method_call (expr, true, method);


        /* -- ASSIGNMENTS -------------------------------------------------- */

        | Assign (LocalRef, val) when val.Throws
        | Assign (LocalRef (local_var), val) when is_void (local_var.Type) =>
          emit (val);
          
        
        /* special case these assignments for performance */
        | Assign (LocalRef (decl), ImplicitValueTypeCtor as ctr) =>
          emit_ce_ref (decl, get_address_for_value_types = true);
          _ilg.Emit (OpCodes.Initobj, ctr.GetSystemType (ref _importer));

     
        /* assignment to ref/out parameter */
        | Assign (LocalRef (local_var), val) when local_var.IsByRefParm =>
          def vars = emit_exprs_prepare ([val]);
          emit_ldarg (local_var.ParmIndex);
          emit_exprs_push (vars, [val]);

          def ty = val.GetSystemType (ref _importer);
          if (ty.IsValueType || ty.IsGenericParameter)
            _ilg.Emit (OpCodes.Stobj, ty)
          else
            _ilg.Emit (OpCodes.Stind_Ref);


        /* assignment to a local variable */
        | Assign (LocalRef (local_var), val) =>
          emit (val);
          unless (val.Throws)
            store_local (local_var);


        /* assignment to a field */
        | Assign (FieldMember (base_object, field) as target, val) =>
          if (val.NeedsEmptyStack) {
            def base_local = declare_expr_local_slot(base_object);
            def val_local = declare_expr_local_slot(val);

            emit (base_object);
            _ilg.Emit (OpCodes.Stloc, base_local);

            emit (val);
            _ilg.Emit (OpCodes.Stloc, val_local);

            _ilg.Emit (OpCodes.Ldloc, base_local);
            when (base_object.GetSystemType(ref _importer).IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.GetSystemType(ref _importer));
            _ilg.Emit (OpCodes.Ldloc, val_local);
          } else {
            emit (base_object);
            when (base_object.GetSystemType(ref _importer).IsGenericParameter)
              _ilg.Emit (OpCodes.Box, base_object.GetSystemType (ref _importer));
            emit (val);
          }
          maybe_volatile (target);

          def field_info = GetFieldInfo (base_object, field);
          
          _ilg.Emit (OpCodes.Stfld, field_info);


        /* assignment to a static field */
        | Assign (StaticRef (t, f is IField, _) as target, val) =>
          emit (val);
          maybe_volatile (target);

          def field_info = GetFieldInfo (t.GetSystemType (ref _importer), f);
          
          _ilg.Emit (OpCodes.Stsfld, field_info);


        /* assignment to an array element */
        | Assign (ArrayIndexer (array_obj, [index]) as target, val) =>
          def type_of_val = val.GetSystemType (ref _importer);
          if (index.NeedsEmptyStack || val.NeedsEmptyStack) {
            def obj_local = declare_expr_local_slot(array_obj);
            def index_local = declare_expr_local_slot(index);
            def val_local = declare_expr_local_slot(val);

            emit (array_obj);
            _ilg.Emit (OpCodes.Stloc, obj_local);

            emit (index);
            _ilg.Emit (OpCodes.Stloc, index_local);

            emit (val);
            _ilg.Emit (OpCodes.Stloc, val_local);

            _ilg.Emit (OpCodes.Ldloc, obj_local);
            _ilg.Emit (OpCodes.Ldloc, index_local);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            _ilg.Emit (OpCodes.Ldloc, val_local);
          } else {
            emit (array_obj);
            emit (index);
            when (type_of_val.IsValueType && !type_of_val.IsPrimitive)
              _ilg.Emit (OpCodes.Ldelema, type_of_val);

            emit (val);
          }
          emit_array_store_opcode (target.GetSystemType (ref _importer));

        | Assign (ArrayIndexer (array_obj, indexes), val) =>
          emit_exprs ([array_obj] + indexes + [val]);
          def method = array_set_method (array_obj);
          emit_method_call (expr, true, method);

        | Assign (This, val) =>
          Util.cassert (_this_is_value_type,
                        "we can assign to 'this' only in valuetypes");
          def vars = emit_exprs_prepare ([val]);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push (vars, [val]);
         
          _ilg.Emit (OpCodes.Stobj, _type_of_this)
          
        | MultipleAssign (assigns) =>
          def emit_store (local_var : LocalValue, _) {
            if (local_var.EverUsed)
              store_local (local_var)
            else
              _ilg.Emit (OpCodes.Pop);
          }
          emit_exprs (assigns.Map ((_, e) => e));
          foreach (assign in assigns.Rev())
            emit_store(assign);


        /* -- CALLS -------------------------------------------------------- */

        /* call the base constructor */
        | Call (Base (base_ctor), ctor_params, _) =>
          def parameters = ctor_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);
          _ilg.Emit (OpCodes.Ldarg_0);
          emit_exprs_push(vars, parameters);

          def from =
            if (base_ctor.DeclaringType.Equals (_parent_type_builder))
              _type_of_this
            else _type_of_this.BaseType;

          def ctr_inf = GetMethodInfo(from, base_ctor, []);
          _ilg.Emit (OpCodes.Call, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);

        /* create a new object */
        | Call (StaticRef (_t, meth is IMethod, _), ctor_params, _) when is_ctor (meth) =>
          emit_parms (ctor_params);

          def ctr_inf = GetMethodInfo(_t, meth, []);
          _ilg.Emit (OpCodes.Newobj, ctr_inf);
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);


        /* emit a call to an instance method, basing on the 'this' pointer for value types */
        | Call (MethodRef (This as th, method, tparms, _), method_params, _)
                                                      when _this_is_value_type =>
          def method_inf = GetMethodInfo (th.Type, method, tparms);
            
          def parameters = method_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);
          
          _ilg.Emit (OpCodes.Ldarg_0);

          // it actually IS the proper way to do it --
          // if this is our method, then we do not need to box
          unless (th.FixedType().Equals (_parent_type_builder.GetMemType ())) {
            _ilg.Emit (OpCodes.Ldobj, _type_of_this);
            _ilg.Emit (OpCodes.Box, _type_of_this);
          }
          emit_exprs_push(vars, parameters);
          
          emit_method_call (expr, true, method_inf, method, th.FixedType())


        /* emit a call to an instance method */
        | Call (MethodRef (base_object, method, tparms, notvirt), method_params, _) =>
          def method_inf = GetMethodInfo (base_object.Type, method, tparms);
          
          def parameters = method_params.Map (_.expr);
          def vars = emit_exprs_prepare (parameters);

          def is_value_type = emit_and_convert_to_address (base_object);

          emit_exprs_push(vars, parameters);

          if (base_object.NeedsConstrained) {
            def is_tail = expr.GenerateTail;
            when (is_tail) {
              expr.GenerateTail = false;
              _ilg.Emit (OpCodes.Tailcall);
            }
            _ilg.Emit (OpCodes.Constrained, base_object.GetSystemType (ref _importer));
            emit_method_call (expr, false, method_inf, method, base_object.FixedType()); // constrained always need callvirt
            when (is_tail)
              _ilg.Emit (OpCodes.Ret);
          } else
            emit_method_call (expr, is_value_type || notvirt, method_inf, method, base_object.FixedType())


        /* emit a call to a static method */
        | Call (StaticRef (_t, mi is IMethod, tparms), method_parms, _) =>
          def method_info = GetMethodInfo (_t, mi, tparms);
        
          Util.cassert (mi.IsStatic,
                        $ "Call TExpr.GlobalRef to a non-static field: $(method_info.Name)");

          emit_parms (method_parms);
          emit_method_call (expr, true, method_info, mi, _t)


        /* emit an operator */
        | Call(OpCode(opcode), parms, _) =>
          // FIXME: seperate out
          emit_parms(parms);
          
          match (opcode)
          {
            | "+.s"                       => _ilg.Emit (OpCodes.Add_Ovf)
            | "+.u"                       => _ilg.Emit (OpCodes.Add_Ovf_Un)
            | "+.f"                       => _ilg.Emit (OpCodes.Add)
            | "+.p"  with inc = true
            | "-.p"  with inc = false     =>
              match (parms)
              {
                | [par1, par2] when par1.expr.Type.IsPointer && par2.expr.Type.Fix().Equals(InternalType.Int32) with type = par1.expr.Type =>
                  def size = get_elem_size(type);
                  
                  _ilg.Emit(OpCodes.Conv_I);
              
                  emit_index_multiplier(size);
                  
                  when (size > 8)
                    _ilg.Emit(OpCodes.Mul);
                  
                  if (inc)
                    _ilg.Emit(OpCodes.Add);
                  else
                    _ilg.Emit(OpCodes.Sub);

                | _ => Util.ice(_method_name + ": incorrect args for TExpr.Opcode (" + opcode + ")")
              }
              
            | "<<.s" | "<<.f"                
            | "<<.u"                      => _ilg.Emit (OpCodes.Shl)
            | ">>.s" | ">>.f"             => _ilg.Emit (OpCodes.Shr)
            | ">>.u"                      => _ilg.Emit (OpCodes.Shr_Un)
            | "unary.+.s" 
            | "unary.+.u" 
            | "unary.+.f"                 => ()
            | "-.s"                       => _ilg.Emit (OpCodes.Sub_Ovf)
            | "-.u"                       => _ilg.Emit (OpCodes.Sub_Ovf_Un)
            | "-.f"                       => _ilg.Emit (OpCodes.Sub)
            | "unary.-.s"                 =>
              _ilg.Emit (OpCodes.Ldc_I4_M1);
              emit_value_type_conversion (expr.Location, InternalType.Int32,
                                          parms.Head.expr.FixedType(), true);
              _ilg.Emit (OpCodes.Mul_Ovf)
            | "unary.-.f"                 => _ilg.Emit (OpCodes.Neg)
            | "unary.~.u"
            | "unary.~.s"                 => _ilg.Emit(OpCodes.Not);
            | "++.i4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add);
            | "--.i4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub);
            | "++.i4.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);
            | "--.i4.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);
            | "++.i4.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);
            | "--.i4.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);            
            | "++.i4.s.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "--.i4.s.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I1);
            | "++.i4.u.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);
            | "--.i4.u.i1"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I1_Un);
            | "++.i4.s.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "--.i4.s.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf);     _ilg.Emit (OpCodes.Conv_Ovf_I2);
            | "++.i4.u.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Add_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);
            | "--.i4.u.i2"                => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Sub_Ovf_Un);  _ilg.Emit (OpCodes.Conv_Ovf_I2_Un);
            | "++.i8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add);
            | "--.i8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub);
            | "++.i8.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add_Ovf);
            | "--.i8.s"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub_Ovf);
            | "++.i8.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Add_Ovf_Un);
            | "--.i8.u"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_I8);     _ilg.Emit (OpCodes.Sub_Ovf_Un);
            | "++.r4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R4);     _ilg.Emit (OpCodes.Add);
            | "--.r4.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R4);     _ilg.Emit (OpCodes.Sub);
            | "++.r8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R8);     _ilg.Emit (OpCodes.Add);
            | "--.r8.f"                   => _ilg.Emit(OpCodes.Ldc_I4_1); _ilg.Emit(OpCodes.Conv_R8);     _ilg.Emit (OpCodes.Sub);
            | "++.p" with inc = true
            | "--.p" with inc = false     => 
              match (parms)
              {
                | [par] when par.expr.Type.IsPointer with type = par.expr.Type =>
                  emit_index_multiplier(type);
                  _ilg.Emit(OpCodes.Conv_I);
                  
                  if (inc)
                    _ilg.Emit(OpCodes.Add);
                  else
                    _ilg.Emit(OpCodes.Sub);

                | _ => Util.ice (_method_name + ": incorrect args for TExpr.Opcode (" + opcode + ")")
              }
              
            | "unary.~.f"                 =>
              def exprType = parms.Head.expr.FixedType();
              when (exprType == InternalType.Single ||
                    exprType == InternalType.Double ||
                    exprType == InternalType.Decimal)
                Util.ice ("float, double or decimal as an argument for binary negation in CGIL");
              _ilg.Emit (OpCodes.Not);

            | "*.s"                       => _ilg.Emit (OpCodes.Mul_Ovf)
            | "*.u"                       => _ilg.Emit (OpCodes.Mul_Ovf_Un)
            | "*.f"                       => _ilg.Emit (OpCodes.Mul)
            | "/.s" | "/.f"               => _ilg.Emit (OpCodes.Div)
            | "/.u"                       => _ilg.Emit (OpCodes.Div_Un)
            | "%.s" | "%.f"               => _ilg.Emit (OpCodes.Rem)
            | "%.u"                       => _ilg.Emit (OpCodes.Rem_Un)
            | "|.s" | "|.u" | "|.f" | "|" => _ilg.Emit (OpCodes.Or);
            | "&.s" | "&.u" | "&.f" | "&" => _ilg.Emit (OpCodes.And);
            | "^.s" | "^.u" | "^.f" | "^" => _ilg.Emit (OpCodes.Xor);
            | "bool.!"                    =>                            InversBool()
            | "==.ref" | "=="             => _ilg.Emit(OpCodes.Ceq);
            | "!=.ref" | "!="             => _ilg.Emit(OpCodes.Ceq);    InversBool();
            | "<.s" | "<.f"               => _ilg.Emit(OpCodes.Clt)
            | "<.u"                       => _ilg.Emit(OpCodes.Clt_Un)
            | ">.s" | ">.f"               => _ilg.Emit(OpCodes.Cgt)
            | ">.u"                       => _ilg.Emit(OpCodes.Cgt_Un)
            | "<=.s"                      => _ilg.Emit(OpCodes.Cgt);    InversBool();
            | "<=.f"                      => _ilg.Emit(OpCodes.Cgt_Un); InversBool();
            | "<=.u"                      => _ilg.Emit(OpCodes.Cgt_Un); InversBool();
            | ">=.s"                      => _ilg.Emit(OpCodes.Clt);    InversBool();
            | ">=.f"                      => _ilg.Emit(OpCodes.Clt_Un); InversBool();
            | ">=.u"                      => _ilg.Emit(OpCodes.Clt_Un); InversBool();
            | _                           => Util.ice (_method_name + ": unmatched TExpr.Opcode (" + opcode + ")")
          }
          
          when (expr.GenerateTail)
            _ilg.Emit (OpCodes.Ret);

        /* -- EXCEPTION HANDLING ------------------------------------------- */

        /* throw an exception */
        | Throw (null) =>
          _ilg.Emit (OpCodes.Rethrow);
        
        | Throw (exc) =>
          emit (exc);
          _ilg.Emit (OpCodes.Throw);


        /* emit the try/with construction */
        | TryFinally (try_expr, finally_expr) =>
          def type_of_try_expr = try_expr.GetSystemType (ref _importer);

          def _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          def ignore_try_result = is_void (try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result)
          {
            try_result = _ilg.DeclareLocal (type_of_try_expr);
            unless (try_expr.Throws)
              _ilg.Emit (OpCodes.Stloc, try_result)
          }

          _ilg.BeginFinallyBlock ();

          emit (finally_expr);

          _ilg.EndExceptionBlock ();

          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        | Try (try_expr, try_cases) =>
          def type_of_try_expr = expr.GetSystemType (ref _importer);

          def ignore_try_result = is_void (try_expr.Type);
          mutable try_result = null;

          unless (ignore_try_result)
            try_result = _ilg.DeclareLocal (type_of_try_expr);

          _ = _ilg.BeginExceptionBlock ();

          emit (try_expr);

          unless (try_expr.Throws || ignore_try_result)
            _ilg.Emit (OpCodes.Stloc, try_result);

          def walk_case (case) {
            | TryCase.Fault (catch_expr) =>
              _ilg.BeginFaultBlock ();
              emit (catch_expr);
            
            | TryCase.Catch (catch_val, catch_expr) =>
              _ilg.BeginCatchBlock (catch_val.Type.GetSystemType (ref _importer));

              def catch_val_local_slot = declare_val_local_slot (catch_val);
              _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);

              emit (catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                _ilg.Emit (OpCodes.Stloc, try_result);

            | TryCase.Filter (catch_val, filter_expr, catch_expr) =>
              def label_badclass = _ilg.DefineLabel ();
              def label_endfilter = _ilg.DefineLabel ();

              // emit filter preamble
              _ilg.BeginExceptFilterBlock ();
              _ilg.Emit (OpCodes.Isinst, catch_val.Type.GetSystemType (ref _importer));
              _ilg.Emit (OpCodes.Dup);
              _ilg.Emit (OpCodes.Brfalse, label_badclass);

              // emit filter block
              def catch_val_local_slot = declare_val_local_slot (catch_val);
              _ilg.Emit (OpCodes.Stloc, catch_val_local_slot);
              emit (filter_expr);
              _ilg.Emit (OpCodes.Br, label_endfilter);

              // when bad class return 0
              _ilg.MarkLabel (label_badclass);
              _ilg.Emit (OpCodes.Pop);
              _ilg.Emit (OpCodes.Ldc_I4_0);

              // mark end of filter
              _ilg.MarkLabel (label_endfilter);

              // emit catch block
              _ilg.BeginCatchBlock (null);
              _ilg.Emit (OpCodes.Pop); // ignore value on stack, it's already local
              emit (catch_expr);

              unless (catch_expr.Throws || ignore_try_result)
                _ilg.Emit (OpCodes.Stloc, try_result);
          }

          foreach (try_case in try_cases)
            walk_case (try_case);

          _ilg.EndExceptionBlock ();

          unless (ignore_try_result)
            _ilg.Emit (OpCodes.Ldloc, try_result);


        /* -- TUPLES -------------------------------------------------------- */
        | Tuple (vals) =>
          emit_exprs (vals);
          def ctor = InternalType.GetTupleType (vals.Length).Ctor;
          _ilg.Emit (OpCodes.Newobj, GetMethodInfo(expr.FixedType() , ctor, []));
          

        | TupleIndexer (obj, pos, len) =>
          def tt = InternalType.GetTupleType (len);
          //when (tt.TyCon.IsValueType && !obj.NeedAddress)
          //  obj.NeedAddress = true;
          emit (obj);
          _ilg.Emit (OpCodes.Ldfld, GetFieldInfo(obj, tt.GetField(pos + 1)));


        /* -- MISC --------------------------------------------------------- */

        /* loads the 'this' pointer on the evaluation stack */
        | This =>
          Util.cassert (!_method_builder.IsStatic, "This is a static method");
          _ilg.Emit (OpCodes.Ldarg_0);
          
          // when we are in value type, this contains address of current
          // value type - so if value is expected instead of address, we must
          // create a copy
          when (_this_is_value_type && !expr.NeedAddress)
            _ilg.Emit (OpCodes.Ldobj, expr.GetSystemType (ref _importer));


        /* loads a literal on the evaluation stack */
        | Literal (l) => 
          Util.cassert (l != null);
          if (l is Literal.Null)
            match (expr.FixedType()) {
              | StaticTypeVarRef 
              | Class (tc,[_]) when tc.Equals (InternalType.Generic_Nullable_tc) =>
                emit (TExpr.DefaultValue (expr.Location, expr.Type))
              | _ => emit_literal (l);
            }
          else if (l is Literal.Void) {
          } else
            emit_literal (l);

        /* loads address of given method */
        | MethodAddress (from, meth, is_virt, typarms) =>
          def meth = GetMethodInfo (from, meth, typarms);
          if (is_virt && (meth :> IBackendMethod).GetMethodInfo().IsVirtual) {
            // ldvirtftn expects also an object reference
            // this is always part of delegate ctor, therefore
            // we can just dup the object reference
            _ilg.Emit (OpCodes.Dup);
            _ilg.Emit (OpCodes.Ldvirtftn, meth);
          } else
            _ilg.Emit (OpCodes.Ldftn, meth);


        /* creates object of value type using implicit ctor */
        | ImplicitValueTypeCtor =>
          def local_slot = declare_expr_local_slot(expr);
          _ilg.Emit (OpCodes.Ldloca, local_slot);
          _ilg.Emit (OpCodes.Initobj, expr.GetSystemType (ref _importer));
          _ilg.Emit (OpCodes.Ldloc, local_slot);


        /* creates a new array, given a list of initializers */
        | Array (initializers, [size]) =>
          def element_type =
            match (expr.Type.Fix ()) {
              | FixedType.Array (t, _) => t.GetSystemType (ref _importer)
              | _ => Util.ice ()
            }
          emit (size);
          _ilg.Emit (OpCodes.Newarr, element_type);

          def need_empty_stack = initializers.Exists (_.NeedsEmptyStack);

          mutable local_array_var = null;
          mutable local_val_var = null;
          when (need_empty_stack) {
            local_array_var = declare_expr_local_slot(expr);
            local_val_var = _ilg.DeclareLocal (element_type);
            _ilg.Emit (OpCodes.Stloc, local_array_var);
            _ilg.Emit (OpCodes.Ldloc, local_array_var);
          }
          
          def load_elements (index : int, elements : list [TExpr])
          {
            match (elements) {
              | [] => ()
              | element :: rest =>
                if (element.NeedsEmptyStack) {
                  _ilg.Emit (OpCodes.Pop); // stack should be empty now

                  emit (element);
                  _ilg.Emit (OpCodes.Stloc, local_val_var);

                  _ilg.Emit (OpCodes.Ldloc, local_array_var);
                  _ilg.Emit (OpCodes.Ldc_I4, index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit (OpCodes.Ldelema, element_type);

                  _ilg.Emit (OpCodes.Ldloc, local_val_var);
                  emit_array_store_opcode (element_type);
                  _ilg.Emit (OpCodes.Ldloc, local_array_var); // restore stack layout for "normal" initializers
                } else {
                  _ilg.Emit (OpCodes.Dup);
                  _ilg.Emit (OpCodes.Ldc_I4, index);

                  when (element_type.IsValueType && !element_type.IsPrimitive)
                    _ilg.Emit (OpCodes.Ldelema, element_type);

                  emit (element);
                  emit_array_store_opcode (element_type);
                }
                load_elements (index + 1, rest)
            }
          }
          load_elements (0, initializers);

        | Array (initializers, dimensions) =>
          emit_exprs (dimensions);

          def arrayType = expr.GetSystemType(ref _importer);
          _ilg.Emit (OpCodes.Newobj, array_ctor(arrayType));

          unless (initializers.IsEmpty)
          {
            def method = array_set_method(arrayType);

            def dimensions_array = array (dimensions.Length);
            mutable i = 0;
            foreach (TExpr.Literal (Literal.Integer (it, _, _)) in dimensions)
            {
              dimensions_array [i] = it;
              ++i;
            }
            Util.cassert (i == dimensions_array.Length,
                          "dimensions must be literals when initializes are supplied");

            def need_empty_stack = initializers.Exists (_.NeedsEmptyStack);

            mutable local_array_var = null;
            mutable local_val_var = null;
            when (need_empty_stack) {
              local_array_var = declare_expr_local_slot(expr);
              local_val_var = _ilg.DeclareLocal (arrayType.Next);
              _ilg.Emit (OpCodes.Stloc, local_array_var);
              _ilg.Emit (OpCodes.Ldloc, local_array_var);
            }

            def load_elements (index : array [ulong], elements : list [TExpr]) {
              match (elements) {
                | [] => ()
                | element :: rest =>
                  if (element.NeedsEmptyStack) {
                    _ilg.Emit (OpCodes.Pop); // stack should be empty now

                    emit (element);
                    _ilg.Emit (OpCodes.Stloc, local_val_var);

                    _ilg.Emit (OpCodes.Ldloc, local_array_var);
                    _ilg.Emit (OpCodes.Dup);

                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));
                    
                    _ilg.Emit (OpCodes.Ldloc, local_val_var);
                  } else {
                    _ilg.Emit (OpCodes.Dup);
                    for (mutable j = 0; j < index.Length; ++j)
                      emit_literal (Literal.Integer ((index [j] :> int) :> ulong, false, InternalType.Int32));
                    emit (element);
                  }
                  def next (index : array [ulong])
                  {
                    ++index [index.Length - 1];
                    for (mutable j = index.Length - 1; index [j] == dimensions_array [j] && j > 0; --j)
                    {
                      index [j] = 0;
                      ++index [j - 1];
                    }
                    index
                  }
                  emit_method_call (expr, true, method);
                  load_elements (next (index), rest)
              }
            }
            load_elements (array (dimensions_array.Length), initializers);
          }

        | DebugInfo as di => emit_debug_info(di);
        | _               => Message.Warning($"FIXME: unmatched: $expr");
      });

      log(EMIT, "} emit");
    }

    /*
     * Emit all expressions and push them onto the stack.
     * Take care when some expressions need an empty stack.
     */
    private emit_exprs (exprs : list[TExpr]) : void
    {
      def vars = emit_exprs_prepare (exprs);
      emit_exprs_push (vars, exprs);
    }
    
    /*
     * Emit all expressions up to the last which needs an empty stack and
     * return the local variables where the result is stored.
     */
    private emit_exprs_prepare (exprs : list[TExpr]) : array[Local]
    {
      def exprs_array = exprs.ToArray ();
      def len = exprs.Length;
      
      mutable needed_local_variables = 0;
      foreach (i in [0 .. len - 1]) {
        when (exprs_array[i].NeedsEmptyStack)
          needed_local_variables = i + 1;
      }

      def local_variables = array (needed_local_variables);

      foreach (i in [0 .. needed_local_variables - 1]) {
        def expr = exprs_array[i];
        def var_type =
          if (expr.NeedAddress)
            make_ref_type (expr.GetSystemType (ref _importer))
          else
            expr.GetSystemType (ref _importer);
        local_variables[i] = _ilg.DeclareLocal (var_type);
        emit (expr);
        _ilg.Emit (OpCodes.Stloc, local_variables[i]);
      }

      local_variables
    }

    /*
     * Push the local variables and emit all expressions with a higher index
     * than the array length
     */
    private emit_exprs_push (local_variables : array[Local], exprs : list[TExpr]) : void {
      foreach (var in local_variables) {
        _ilg.Emit (OpCodes.Ldloc, var);
      }

      mutable i = 0;
      foreach (e in exprs) {
        when (i >= local_variables.Length) {
          emit (e);
        }
        i++;
      }
    }
    
    private emit_debug_info(di : TExpr.DebugInfo) : void
    {
      if (_debug_doc == null)
        emit(di.expr);
      else if (di.expr is TExpr.DebugInfo)
        emit_debug_info(di.expr :> TExpr.DebugInfo)
      else
      {

        def emit_debug (doc, line, col, eline, ecol)
        {
          _ilg.MarkSequencePoint (doc, line, col, eline, ecol);
        }

        def l = di.Location;
        def expr_doc = DefineDebugDocument(di.Location.FileIndex); // TExpr source file (possible from #line pragma)
        
        match (di.pexpr)
        {
          | Sequence =>
            emit_debug (expr_doc, l.Line, l.Column, l.Line,    l.Column + 1);
            _ilg.BeginScope ();

          | _ => emit_debug (expr_doc, l.Line, l.Column, l.EndLine, l.EndColumn);
        }

        unless (di.expr == null)
          emit (di.expr);

        match (di.pexpr)
        {
          | Sequence =>
            emit_debug (expr_doc, l.EndLine, l.EndColumn - 1, l.EndLine, l.EndColumn);
            _ilg.EndScope ();

          | _ => ()
        }
      }
    }

    private array_set_method (arr : TExpr) : DN.IMethod
    {
        array_set_method (arr.GetSystemType (ref _importer));
    }

    private array_set_method (t : DN.TypeSig) : DN.IMethod
    {
      | t is DN.ArraySig =>
        def rank = t.Rank :> int;
        def argTypes = array(rank + 1);
        for (mutable i = 0; i < rank; ++i)
          argTypes[i] = _module_builder.CorLibTypes.Int32;
        argTypes[rank] = t.Next;

        def methodSig = DN.MethodSig.CreateInstance(_module_builder.CorLibTypes.Void, argTypes);
        DN.MemberRefUser(_module_builder, "Set", methodSig, DN.TypeSpecUser(t))

      | _ => Util.ice($"expected array signature got $t")
    }


    /*
     * Emits a local reference instruction
     */
    private emit_ce_ref (decl : LocalValue, get_address_for_value_types : bool) : void
    {
      if (decl.IsParm) {
        if (get_address_for_value_types && ! decl.IsByRefParm)
          emit_ldarga (decl.ParmIndex)
        else {
          emit_ldarg (decl.ParmIndex);
          when (! get_address_for_value_types && decl.IsByRefParm) {
            def ty = decl.Type.GetSystemType (ref _importer);
            if (ty.IsGenericParameter || ty.IsValueType)
               emit_ldind_for_value_type (ty)
            else
              _ilg.Emit (OpCodes.Ldind_Ref);
          }
        }
      } else {
        if (get_address_for_value_types && !decl.IsManagedPtr)
          _ilg.Emit (OpCodes.Ldloca, decl.LocalSlot)
        else
          _ilg.Emit (OpCodes.Ldloc, decl.LocalSlot)
      }
    }

    private array_get_method (arr : TExpr) : DN.IMethod
    {
      array_get_method (arr.GetSystemType (ref _importer));
    }

    private array_get_method (t : DN.TypeSig) : DN.IMethod
    {
      | t is DN.ArraySig =>
        def argTypes = array(t.Rank :> int);
        for (mutable i = 0; i < argTypes.Length; ++i)
          argTypes[i] = _module_builder.CorLibTypes.Int32;

        def methodSig = DN.MethodSig.CreateInstance(t.Next, argTypes);
        DN.MemberRefUser(_module_builder, "Get", methodSig, DN.TypeSpecUser(t))

      | _ => Util.ice($"expected array signature got $t")
    }

    private array_addr_method (arr : TExpr) : DN.IMethod
    {
      array_addr_method (arr.GetSystemType (ref _importer));
    }

    private array_addr_method (t : DN.TypeSig) : DN.IMethod
    {
      | t is DN.ArraySig =>
        def argTypes = array(t.Rank :> int);
        for (mutable i = 0; i < argTypes.Length; ++i)
          argTypes[i] = _module_builder.CorLibTypes.Int32;

        def methodSig = DN.MethodSig.CreateInstance(make_ref_type(t.Next), argTypes);
        DN.MemberRefUser(_module_builder, "Address", methodSig, DN.TypeSpecUser(t))

      | _ => Util.ice($"expected array signature got $t")
    }

    private array_ctor(t : DN.TypeSig) : DN.IMethod
    {
      | t is DN.ArraySig =>
          def argTypes = array(t.Rank :> int);
          for (mutable i = 0; i < argTypes.Length; ++i)
            argTypes [i] = _module_builder.CorLibTypes.Int32;

          def methodSig = DN.MethodSig.CreateInstance(_module_builder.CorLibTypes.Void, argTypes);
          DN.MemberRefUser(_module_builder, ".ctor", methodSig, DN.TypeSpecUser(t))

      | _ => Util.ice($"expected array signature got $t")
    }

    /**
     * Emits the TExpr.Switch instruction
     *
     * Asserts that the first of the case indices is zero. Quietly
     * asserts that the indexer is verified to be in a valid range -- i.e.
     * that the rescaling substraction does not overflow and that we never
     * generate too long switch instructions -- assuring this should belong
     * to a higher level logic.
     */
    private emit_switch (default_expr : option [TExpr], 
                         cases : list [int * TExpr]) : void
    {
      def label_default = _ilg.DefineLabel ();
      def label_next_instruction = _ilg.DefineLabel ();

      // step zero: calculate the default jump target
      def default_jump_target =
        match (default_expr)
        {
          | Some => label_default
          | None => label_next_instruction
        };

      // step one: sort the cases increasingly
      def compare_cases (l : int * TExpr, r : int * TExpr) : int
      {
        Pair.First (l).CompareTo (r [0])
      }

      def cases = cases.Sort(compare_cases);
      Util.cassert (cases.Head [0] == 0);

      // step three: generate the jump labels for the switch cases
      mutable reversed_labels = [];

      def make_labels (index : int, cases : list [int * TExpr]) : list [Label * TExpr] 
      {
        Util.cassert (index >= 0);
        match (cases) {
          | (case_index, case_expr) :: rest =>
            Util.cassert (index <= case_index);

            // insert jumps to the default expression where appropriate
            if (case_index == index) {
              def case_label = _ilg.DefineLabel ();
              reversed_labels = case_label :: reversed_labels;

              (case_label, case_expr) :: make_labels (index + 1, rest)
            }
            else {
              reversed_labels = default_jump_target :: reversed_labels;
              make_labels (index + 1, cases)
            }
          | [] => []
        }
      }

      def labeled_cases = make_labels (0, cases);
      def labels_array = reversed_labels.ToArray ();
      System.Array.Reverse (labels_array);

      // step four: emit the switch instruction and the default expression
      _ilg.Emit (OpCodes.Switch, labels_array);
      _ilg.MarkLabel (label_default);

      // emit the default expression (if none present jump to the next instruction)
      match (default_expr)
      {
        | Some (default_expr) =>
          emit (default_expr);
          unless (default_expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
        | None =>
          _ilg.Emit (OpCodes.Br, label_next_instruction);
      }

      // step five: emit the switch cases
      def walk_cases (cases : list [Label * TExpr]) : void
      {
        | (label, expr) :: rest =>
          _ilg.MarkLabel (label);
          emit (expr);
          unless (expr.Throws)
            _ilg.Emit (OpCodes.Br, label_next_instruction);
          walk_cases (rest)
        | [] => ()
      }

      walk_cases (labeled_cases);

      // step six: mark the next instruction after the switch
      _ilg.MarkLabel (label_next_instruction);
    }


    /**
     * Emits an LDARG instruction
     */
    private emit_ldarg (index : int) : void
    {
      | 0 => _ilg.Emit (OpCodes.Ldarg_0)
      | 1 => _ilg.Emit (OpCodes.Ldarg_1)
      | 2 => _ilg.Emit (OpCodes.Ldarg_2)
      | 3 => _ilg.Emit (OpCodes.Ldarg_3)
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarg_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarg, index)
    }


    private store_argument (index : int) : void
    {
      if (index < 256)
        _ilg.Emit (OpCodes.Starg_S, index :> byte)
      else
        _ilg.Emit (OpCodes.Starg, index);
    }

    
    /**
     * Emits an LDARGA instruction
     */
    private emit_ldarga (index : int) : void
    {
      | n when n <= 255 => _ilg.Emit (OpCodes.Ldarga_S, (index :> System.Byte))
      | _ => _ilg.Emit (OpCodes.Ldarga, index)
    }

    /**
     * Performs value type conversion form l to r
     */
    private emit_value_type_conversion (loc : Location,
                                        l_t : FixedType, r_t : FixedType,
                                        is_checked : bool) : void
    {
      def fail()
      {
        Message.Warning (loc, $"failed to emit value type conversion from $l_t to $r_t")
      }
      
      unless (l_t.Equals (r_t))
      {
        mutable lt = l_t.TypeInfo;
        when (lt.IsEnum) lt = lt.UnderlyingType.TypeInfo;
        mutable rt = r_t.TypeInfo;  
        when (rt.IsEnum) rt = rt.UnderlyingType.TypeInfo;

        match (rt, lt)
        {
          | (rt is ExternalPrimitiveTypeInfo, lt is ExternalPrimitiveTypeInfo)
            when lt.CanOmmitConversionTo(rt) 
              => ()

          | (rt is ExternalPrimitiveTypeInfo, lt) =>
            def is_unsigned_l = 
              match (lt.Name [0])
              {
                // UInt32, UInt64, UInt16
                | 'U'
                // Byte
                | 'B'
                // Char
                | 'C'   => true
                | _ => false
              }
          
            def rname = rt.Name;
            def opcode =
              match (rname)
              {
                | "Single" when is_unsigned_l => OpCodes.Conv_R_Un
                | "Single"                    => OpCodes.Conv_R4
                | "Double" when is_unsigned_l => _ilg.Emit (OpCodes.Conv_R_Un); OpCodes.Conv_R8                
                | "Double"                    => OpCodes.Conv_R8
                | _ =>
                  if (is_checked)
                    match (rname)
                    {
                      | "Int64" when is_unsigned_l   => OpCodes.Conv_Ovf_I8_Un
                      | "Int64"                      => OpCodes.Conv_Ovf_I8
                      | "Int32" when is_unsigned_l   => OpCodes.Conv_Ovf_I4_Un
                      | "Int32"                      => OpCodes.Conv_Ovf_I4
                      | "Int16" when is_unsigned_l   => OpCodes.Conv_Ovf_I2_Un
                      | "Int16"                      => OpCodes.Conv_Ovf_I2
                      | "SByte" when is_unsigned_l   => OpCodes.Conv_Ovf_I1_Un
                      | "SByte"                      => OpCodes.Conv_Ovf_I1
                      | "UInt64" when is_unsigned_l  => OpCodes.Conv_Ovf_U8_Un
                      | "UInt64"                     => OpCodes.Conv_Ovf_U8
                      | "UInt32" when is_unsigned_l  => OpCodes.Conv_Ovf_U4_Un
                      | "UInt32"                     => OpCodes.Conv_Ovf_U4
                      | "UInt16" when is_unsigned_l  => OpCodes.Conv_Ovf_U2_Un
                      | "UInt16"                     => OpCodes.Conv_Ovf_U2
                      | "Boolean" when is_unsigned_l => OpCodes.Conv_Ovf_U1_Un
                      | "Boolean"                    => OpCodes.Conv_Ovf_U1
                      | "Byte" when is_unsigned_l    => OpCodes.Conv_Ovf_U1_Un
                      | "Byte"                       => OpCodes.Conv_Ovf_U1
                      | "Char" when is_unsigned_l    => OpCodes.Conv_Ovf_U2_Un
                      | "Char"                       => OpCodes.Conv_Ovf_U2
    
                      | _ => fail (); OpCodes.Nop
                    }
                  else match (rname)
                  {
                    | "Int64" when is_unsigned_l => OpCodes.Conv_U8
                    | "Int64"   => OpCodes.Conv_I8
                    | "Int32"   => OpCodes.Conv_I4
                    | "Int16"   => OpCodes.Conv_I2
                    | "SByte"   => OpCodes.Conv_I1
                    | "UInt64" when !is_unsigned_l => OpCodes.Conv_I8
                    | "UInt64"  => OpCodes.Conv_U8
                    | "UInt32"  => OpCodes.Conv_U4
                    | "UInt16"  => OpCodes.Conv_U2
                    | "Byte"    => OpCodes.Conv_U1
                    | "Boolean" => OpCodes.Conv_U1
                    | "Char"    => OpCodes.Conv_U2
                    | _         => fail (); OpCodes.Nop
                  }
              };

            _ilg.Emit (opcode)
            
          | _ when rt.Equals(InternalType.Decimal_tc) =>
            def lname = lt.Name;
            match (lname)
            {
              | "Int32" | "UInt32" | "Single" | "Int64" | "UInt64" | "Double" =>
                _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get (lname)))

              | _ => fail ()
            }
            
          | _ => fail ()
        }
      }
    }


    /**
     * Emits a method call.
     *
     * If it is a tail call (which is checked based on [expr]), then we emit
     * tail modifier.
     */
    private emit_method_call (expr : TExpr,
                              base_is_value_type_or_static : bool,
                              method : DN.IMethod,
                              imethod : IMethod = null,
                              from : FixedType = null) : void
    {
      // Message.Debug ($"emc: $(method.Name)");
      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Tailcall);

      if (base_is_value_type_or_static)
      {
        _ilg.Emit (OpCodes.Call, method);
      }
      else if (method.DeclaringType.Name == "Array" && method.DeclaringType.Namespace == "System" && method.Name == "get_Length")
      {
        _ilg.Emit(OpCodes.Ldlen);
        _ilg.Emit(OpCodes.Conv_I4);
      }
      else
      {
        _ilg.Emit (OpCodes.Callvirt, method);
      }

      when (imethod != null)
        emit_tuple_function_conversion (expr.FixedType(), from, imethod);

      when (expr.GenerateTail)
        _ilg.Emit (OpCodes.Ret);
    }

    /* Emits code of given expression and converts its value to adress
       (if it is a value type) or leave it as reference (non value type).
       This is needed in various places, where we need a real reference
       (address in case of value types) to access its methods or fields.

       Returns value indicating if base_object was really a value type
    */
    private emit_and_convert_to_address (base_object : TExpr) : bool 
    {
      emit (base_object);
      def stype = base_object.GetSystemType (ref _importer);
      def is_value_type = stype.IsValueType;

      // we must allocate additional temporary variable if during
      // emit(base_object) address was not granted
      when ((is_value_type || stype.IsGenericParameter) && !base_object.NeedAddress)
      {
        def local_slot = _ilg.DeclareLocal(stype);
        _ilg.Emit (OpCodes.Stloc, local_slot);
        _ilg.Emit (OpCodes.Ldloca, local_slot);
      }
      // is_value_type is checked to decide in call vs callvirt emission
      is_value_type
    }


    /**
     * Declares a local variable
     */
    private declare_val_local_slot (val : LocalValue) : Local
    {
      def ty =
        if (val.IsManagedPtr)
          make_ref_type(val.Type.GetSystemType (ref _importer))
        else val.Type.GetSystemType (ref _importer);

      def local_slot = _ilg.DeclareLocal(ty, val.IsPinned);
      when (IsDebugEnabled && val.Location.IsSourceAvailable)
        local_slot.SetLocalSymInfo (val.Name);
      val.LocalSlot = local_slot;
      local_slot
    }

    private declare_val_local_slot_ex (val : LocalValue) : void
    {
      if (val.PostponedDeclaration && IsDebugEnabled && val.Location.IsSourceAvailable)
        val.Declare = fun() { _ = declare_val_local_slot (val) };
      else
        _ = declare_val_local_slot (val)
    }

    private declare_expr_local_slot(expr : TExpr) : Local
    {
      def ty =
        if(expr.NeedAddress && expr.IsAddressable)
          make_ref_type(expr.GetSystemType(ref _importer))
        else
          expr.GetSystemType(ref _importer);
      _ilg.DeclareLocal(ty)
    }

    /**
     * Emits a STELEM instruction for a given type
     *
     * NOTE: there is no Stelem_U* in System.Reflection.Emit.OpCodes.
     */
    private emit_array_store_opcode (ty : DN.TypeSig) : void
    {
      if (ty.IsGenericParameter) _ilg.Emit (OpCodes.Stelem, ty)
      else if (ty.IsPrimitive)
      {
        def (opcode, _ , _) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit(opcode);
      }
      else if (ty.IsValueType) _ilg.Emit (OpCodes.Stobj, ty)
      else _ilg.Emit (OpCodes.Stelem_Ref);
    }

    private emit_value_to_ptr_conversion(expr : TExpr, target_type : TypeVar) : void
    {
      def type = expr.Type.Fix();
      
      match (type)
      {
        | Class(_, []) when type.Equals(InternalType.IntPtr) =>
          emit(expr);
          
        | Class(_, []) when type.Equals(InternalType.String) =>
          _ = target_type; // TODO: Add check!
        
          emit(expr);
        
          def label = _ilg.DefineLabel();
        
          _ilg.Emit(OpCodes.Conv_I);                                                      //       conv.i
          _ilg.Emit(OpCodes.Dup);                                                         //       dup
          _ilg.Emit(OpCodes.Brfalse_S, label);                                            //       brfalse.s Label
                                                               
          _ilg.Emit(OpCodes.Call, SystemTypeCache.RuntimeHelpers_get_OffsetToStringData); //       call int32 [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::get_OffsetToStringData()
          _ilg.Emit(OpCodes.Add);                                                         //       add

          _ilg.MarkLabel(label);
        
        | FixedType.Array(t, 1) =>
          emit(expr);
          _ilg.Emit(OpCodes.Ldc_I4_0);
          _ilg.Emit(OpCodes.Ldelema, SystemHelpers.GetSystemType(t, ref _importer));
          _ilg.Emit(OpCodes.Conv_I);
          
        | _ => assert(false, "Unsupported pointer convertion.");
      }
    }

    private static get_elem_size(ptr_type : TypeVar) : int
    {
      def ptrType  = ptr_type.Fix();
      def elemType = ptrType.TypeInfo.GetElementTypeInfo();
      def size = elemType.Value.Size;
      assert(size > 0);
      size
    }

    private emit_index_multiplier(ptr_type : TypeVar) : void
    {
      emit_index_multiplier(get_elem_size(ptr_type))
    }
    
    private emit_index_multiplier(size : int) : void
    {
      | 8  => ()
      | 16 => _ilg.Emit(OpCodes.Ldc_I4_2);
      | 32 => _ilg.Emit(OpCodes.Ldc_I4_4);
      | 64 => _ilg.Emit(OpCodes.Ldc_I4_8);
      | _  => assert(false);
    }
    
    private emit_ptr_indexing(needAddress : bool, ptr : TExpr, index : TExpr) : void
    {
      def type = ptr.Type;
      
      assert(type.IsPointer);
      emit(ptr);
      
      def size = get_elem_size(type);
      
      match (index)
      {
        | TExpr.Literal(Literal.Integer(0, _, _)) => ()
        | TExpr.Literal(Literal.Integer(val, is_negative, _treat_as)) =>
          def byteOffset = (size / 8) * (val :> int) * if (is_negative) -1 else 1;
          
          _ilg.Emit(OpCodes.Conv_I);
          _ilg.Emit(byteOffset);
          _ilg.Emit(OpCodes.Add);
        
        | _ =>
          emit(index);
          _ilg.Emit(OpCodes.Conv_I);
          emit_index_multiplier(size);

          when (size > 8)
            _ilg.Emit(OpCodes.Mul);
          
          _ilg.Emit(OpCodes.Add);
      }
      
      unless (needAddress)
        match (size)
        {
          | 8  => _ilg.Emit(OpCodes.Ldind_U1);
          | 16 => _ilg.Emit(OpCodes.Ldind_U2);
          | 32 => _ilg.Emit(OpCodes.Ldind_U4);
          | 64 => _ilg.Emit(OpCodes.Ldind_I8);
          | _  => assert(false);
        }
    }

    /**
     * Emits a LDELEM instruction for a given type
     */
    private emit_array_load_opcode (ty : DN.TypeSig) : void
    {
      if (ty.IsGenericParameter)
        _ilg.Emit (OpCodes.Ldelem, ty)
      else if (ty.IsValueType && !ty.IsPrimitive)
      {
        _ilg.Emit (OpCodes.Ldelema, ty);
        _ilg.Emit (OpCodes.Ldobj, ty);
      } 
      else if (ty.IsPrimitive)
      {
        def (_, opcode, _) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit(opcode)
      }
      else
        _ilg.Emit(OpCodes.Ldelem_Ref)
    }


    /**
     * Emits a LDIND instruction for a given value type
     */
    private emit_ldind_for_value_type (ty : DN.TypeSig) : void
    {
      if (!ty.IsPrimitive || ty.IsEnum)
        _ilg.Emit (OpCodes.Ldobj, ty)
      else
      {
        def (_, _ , opcode) = _primitiveTypeArrayOpcodes[(ty :> DN.TypeDefOrRefSig).TypeDefOrRef.Name];
        _ilg.Emit (opcode)
      }
    }

    /// Emits a literal
    private emit_literal (l : Literal) : void
    {
      match (l) {
        | Literal.Void         => ()
        | Literal.Null         => _ilg.Emit (OpCodes.Ldnull)
        | Literal.Bool (flag)  => _ilg.Emit (flag)
        | Literal.Char (k)     => _ilg.Emit (k :> int)

        | Literal.Integer (k, is_neg, t) =>
          assert(t != null);
          if (t.Equals (InternalType.UInt64)) {
            assert(!is_neg);
            unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
            // i don't think this is needed here
            _ilg.Emit (OpCodes.Conv_U8)
          } else if (t.Equals (InternalType.Int64)) {
            if (is_neg)
              if (k == 0x8000000000000000UL)
                _ilg.Emit (OpCodes.Ldc_I8, System.Int64.MinValue);
              else
                _ilg.Emit (OpCodes.Ldc_I8, - (k :> long));
            else
              unchecked (_ilg.Emit (OpCodes.Ldc_I8, k :> long));
          } else if (t.Equals (InternalType.UInt32)) {
            assert(!is_neg);
            _ilg.Emit (unchecked (k :> int))
          } else
            if (k <= System.Int32.MaxValue :> ulong)
              _ilg.Emit (if (is_neg) - (k :> int) else (k :> int))
            else if (k == (- (System.Int32.MinValue : long)) :> ulong && is_neg)
              _ilg.Emit (System.Int32.MinValue)
            else {
              Message.Warning ($ "cannot emit: $l : $t");
              assert(false)
            }
          
        | Literal.String (s)   =>
          assert(s != null); _ilg.Emit (OpCodes.Ldstr, s)
          
        | Literal.Float (f)    => _ilg.Emit (OpCodes.Ldc_R4, f)
        | Literal.Double (f)   => _ilg.Emit (OpCodes.Ldc_R8, f)
        | Literal.Decimal (m)  =>
          def decimal_bits = System.Decimal.GetBits (m);

          def sign = decimal_bits[3] < 0;
          def scale = (decimal_bits[3] >> 16) & 0x00FF;

          if(decimal_bits[2] != 0 || (decimal_bits[1] < 0 && sign) || scale != 0) {
            // constant is too huge to fit in 32 or 64 bit integer

            _ilg.Emit(decimal_bits[0]);
            _ilg.Emit(decimal_bits[1]);
            _ilg.Emit(decimal_bits[2]);
            _ilg.Emit(sign);
            _ilg.Emit(scale);

            _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("Int32, Int32, Int32, Boolean, Byte")));

          } else if(decimal_bits[1] != 0 || (decimal_bits[0] < 0 && sign)) {
            // constant fits into 64 bit integer

            def val : long = unchecked( (((decimal_bits[1] :> ulong) << 32) %| (decimal_bits[0] :> ulong)) :> long );
            if(sign) {
              assert(val >= 0L);
              def val : long = unchecked( (val :> ulong %| 0x800000000000000UL) :> long );
              _ilg.Emit (OpCodes.Ldc_I8, val);
              _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("Int64")));
            } else {
              _ilg.Emit (OpCodes.Ldc_I8, val);
              _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("UInt64")));
            }

          } else {
            // constant fits into 32 bit integer 

            def val : int = decimal_bits[0];
            if(sign) {
              assert(val >= 0);
              def val : int = unchecked( (val :> uint %| 0x80000000U) :> int );
              _ilg.Emit (OpCodes.Ldc_I4, val);
              _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("Int32")));
            } else {
              _ilg.Emit (OpCodes.Ldc_I4, val);
              _ilg.Emit (OpCodes.Newobj, Option.UnSome (SystemTypeCache.Decimal_ctors.Get ("UInt32")));
            }
          }

        | Literal.Enum (l, _, _) => emit_literal (l)
      }
    }

#pragma warning disable 10003
    class Label
    {
      public mutable TargetIndex      : ValueOption[int];
      public mutable ResolveCallbacks : list[Instruction -> void] = [];
    }

    class ExceptionLabels
    {
      public this(ilg : NemerleGenerator)
      {
        TryStart = ilg.DefineLabel();
        TryEnd   = ilg.DefineLabel();
        Exit     = ilg.DefineLabel();
      }

      public         TryStart : Label;
      public         TryEnd   : Label;
      public         Exit     : Label;
      public mutable Handler  : ExceptionHandler;

      private mutable _currentEnd : Label;

      public CurrentEnd : Label { get { _currentEnd ?? TryEnd } set { _currentEnd = value } }
    }

    class NemerleGenerator
    {
      private _il                 : SCG.List[Instruction]      = SCG.List();
      private _exceptions         : SCG.List[ExceptionHandler] = SCG.List();
      private _locals             : SCG.List[Local]            = SCG.List();
      private _jumpedLabels       : SCG.HashSet[Label]         = SCG.HashSet();
      private _markedLabels       : SCG.Queue[Label]           = SCG.Queue();
      private _exceptionLabels    : SCG.Stack[ExceptionLabels] = SCG.Stack();
      private mutable _throw      : bool;
      private mutable _marked     : bool;
      private mutable _first_code : bool = true;
      private mutable _document   : ISymbolDocumentWriter;

      public CreateBody() : CilBody
      {
        CilBody(true, _il, _exceptions, _locals)
      }

      public SetDocument (document : ISymbolDocumentWriter) : void
      {
        _document = document;
      }

      public BeginExceptionBlock() : void
      {
        def labels = ExceptionLabels(this);
        _exceptionLabels.Push(labels);
        MarkLabel(labels.TryStart);
      }

      public BeginCatchBlock(exceptionType : DN.TypeSig) : void
      {
        def labels = _exceptionLabels.Peek();
        if (exceptionType == null)
        {
          def handler = labels.Handler;
          Util.cassert(handler != null);

          def handlerStart = DefineLabel();
          ResolveLabel(handlerStart, fun(target) { handler.HandlerStart = target });
          MarkLabel(handlerStart, true);
        }
        else
        {
          CloseCurrentExceptionBlock(labels);

          def handler = ExceptionHandler(ExceptionHandlerType.Catch);
          handler.CatchType = DN.Extensions.ToTypeDefOrRef(exceptionType);
          ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
          ResolveLabel(labels.TryEnd,     fun(target) { handler.TryEnd       = target });
          ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerStart = target });
          labels.CurrentEnd = DefineLabel();
          ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

          AddExceptionHandler(labels, handler);
        }
      }

      public BeginExceptFilterBlock() : void 
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Filter);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart    = target });
        ResolveLabel(labels.TryEnd,     fun(target) { handler.TryEnd      = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.FilterStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd,  fun(target) { handler.HandlerEnd = target });

        AddExceptionHandler(labels, handler);
      }

      public BeginFaultBlock() : void
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Fault);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.TryEnd       = target;
                                                      handler.HandlerStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

        AddExceptionHandler(labels, handler);
      }

      public BeginFinallyBlock() : void
      {
        def labels = EnterExceptionBlock();

        def handler = ExceptionHandler(ExceptionHandlerType.Finally);
        ResolveLabel(labels.TryStart,   fun(target) { handler.TryStart     = target });
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.TryEnd       = target;
                                                      handler.HandlerStart = target });
        labels.CurrentEnd = DefineLabel();
        ResolveLabel(labels.CurrentEnd, fun(target) { handler.HandlerEnd   = target });

        AddExceptionHandler(labels, handler);
      }

      public EndExceptionBlock() : void
      {
        def labels = _exceptionLabels.Pop();
        CloseCurrentExceptionBlock(labels);
        MarkLabel(labels.Exit, true);
      }

      public BeginScope () : void { /*_ilg.BeginScope()*/ }
      public EndScope   () : void { /*_ilg.EndScope  ()*/ }

      public DeclareLocal (localType : DN.TypeSig, pinned : bool = false) : Local
      {
        def local = Local(if (pinned) DN.PinnedSig(localType) else localType);
        _locals.Add(local);
        local
      }

      public DefineLabel () : Label { Label() }

      public Emit(flag   : bool)                           : void { Emit(if (flag) OpCodes.Ldc_I4_1 else OpCodes.Ldc_I4_0) }
      public Emit(number : int)                            : void { Add(Instruction.CreateLdcI4(number)) }
      public Emit(opcode : OpCode)                         : void { Add(opcode.ToInstruction())    }
      public Emit(opcode : OpCode, arg : byte)             : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : sbyte)            : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : short)            : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : int)              : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : long)             : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : float)            : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : double)           : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : string)           : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.IMethod)       : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.IField)        : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : DN.TypeSig)       : void { Add(opcode.ToInstruction(DN.Extensions.ToTypeDefOrRef(arg))) }
      public Emit(opcode : OpCode, arg : DN.ITypeDefOrRef) : void { Add(opcode.ToInstruction(arg)) }
      public Emit(opcode : OpCode, arg : Local)            : void { Add(opcode.ToInstruction(arg)) }

      public Emit(opcode : OpCode, arg : Label)      : void
      {
        def instruction = opcode.ToInstruction(null : Instruction);
        Add(instruction);
        ResolveLabel(arg, fun(target) { instruction.Operand = target });
      }

      public Emit(opcode : OpCode, labels : array[Label]) : void
      {
        def jumpTable = SCG.List();

        Add(opcode.ToInstruction(jumpTable));

        foreach (label in labels)
        {
          def index = jumpTable.Count;
          jumpTable.Add(null);
          ResolveLabel(label, fun(target) { jumpTable[index] = target });
        }
      }

      public MarkLabel(label : Label, reset_throw : bool = false) : void
      {
        Util.cassert(label.TargetIndex.IsNone, "Label already marked");

        when (reset_throw || _jumpedLabels.Contains(label))
          _throw = false;

        label.TargetIndex = VSome(_il.Count);
        _markedLabels.Enqueue(label);

        when (_marked)
        {
          _marked = false;

          // Hide from the debugger.
          //
          _ilg.MarkSequencePoint (_document, 0xFeeFee, 0, 0xFeeFee, 0);
          if (!_throw)
            Emit(OpCodes.Nop);
          else
            Emit(OpCodes.Br, label); // VladD2: HACK: This hack hide a dead code. We must remove this hack and implement a full calculation and elimination of dead code.
        }
      }

      public MarkSequencePoint (document : ISymbolDocumentWriter, startLine : int, startColumn : int, endLine : int, endColumn : int) : void
      {
        unless (_throw)
        {
          _marked = true;

          _ilg.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn);
          Emit(OpCodes.Nop);
        }
      }

      private ResolveLabel(label : Label, callback : Instruction -> void) : void
      {
        _ = _jumpedLabels.Add(label);

        if (label.TargetIndex is VSome(index))
          callback(_il[index]);
        else
          label.ResolveCallbacks ::= callback;
      }

      private Add(instruction : Instruction) : void
      {
        _il.Add(instruction);

        while (_markedLabels.Count > 0)
        {
          def label = _markedLabels.Dequeue();
          foreach (callback in label.ResolveCallbacks)
            callback(instruction);
          label.ResolveCallbacks = null;
        }

        when (_first_code)
        {
          _first_code = false;

          when (_document != null && !_marked)
            _ilg.MarkSequencePoint (_document, 0xFeeFee, 0, 0xFeeFee, 0);
        }

        match (instruction.OpCode.Code)
        {
          | Throw | Rethrow | Br | Leave | Ret => _throw = true
          | _ => ()
        }
      }

      private AddExceptionHandler(labels : ExceptionLabels, handler : ExceptionHandler) : void
      {
        labels.Handler = handler;
        _exceptions.Add(handler);
        _throw = false;
      }

      private EnterExceptionBlock() : ExceptionLabels
      {
        def labels = _exceptionLabels.Peek();
        CloseCurrentExceptionBlock(labels);
        labels
      }

      private CloseCurrentExceptionBlock(labels : ExceptionLabels) : void
      {
        unless (_throw)
          Emit(OpCodes.Leave, labels.Exit);
        MarkLabel(labels.CurrentEnd);
      }
    }

    #pragma warning restore 10003

  } // end of the class
} // end of the namespace
