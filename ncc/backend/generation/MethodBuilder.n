using Nemerle.Compiler.Backend;
using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Utility;

using System.Reflection;
using System.IO;
using System.Diagnostics.SymbolStore;
using System.Diagnostics;
using System.Security;

using NC = Nemerle.Compiler;
using SR = System.Reflection;
using SRE = System.Reflection.Emit;

namespace Nemerle.Compiler
{
  public partial class MethodBuilder : IBackendMember, IBackendMethod
  {
    mutable method_base : SR.MethodBase;

    public GetMethodBuilder() : SRE.MethodBuilder
    {
      assert(method_base != null && !method_base.IsConstructor, declaring_type.FullName + "." + Name);
      method_base :> SRE.MethodBuilder
    }
    
    public GetConstructorInfo() : SRE.ConstructorBuilder
    {
      assert(method_base != null/* && method_base.IsConstructor*/);
      method_base :> SRE.ConstructorBuilder
    }

    GetHandle() : SR.MemberInfo
      implements IBackendMember.GetHandle
    {
      GetMethodBase()
    }
    
    GetMethodInfo() : SR.MethodInfo
      implements IBackendMethod.GetMethodInfo
    {
      GetMethodBuilder()
    }

    GetMethodBase() : SR.MethodBase
      implements IBackendMethod.GetMethodBase
    {
      assert(method_base != null);
      method_base
    }

    internal override CreateEmitBuilder (tb : Emit.TypeBuilder) : void
    {
      when (SkipEmiting)
        return;

      if (MemberKind == MemberKinds.Constructor)
        CreateConstructorBuilder (tb)
      else
        CreateMethodBuilder (tb)
    }

    /**
     * Emits a method's body
     */
    internal CompileAfterTyping () : void
    {
      when (SkipEmiting)
        return;

      def setup_method(emitter)
      {
        // make sure type is not finalized
        def type_builder = declaring_type.GetTypeBuilder();
        assert(type_builder != null);

        def mb = GetMethodInfo();
        Util.cassert (mb != null, $"method builder is null for $this");

        /* update the entry point settings, if necessary */
        when (emitter._need_entry_point && Name == "Main"
          && (Manager.Options.MainClass == null
           || declaring_type.FullName == Manager.Options.MainClass
           || Manager.Options.IsMainClassAutogenerated))
        {
          def has_correct_signature ()
          {
            mb.IsStatic &&
            (ReturnType.Equals(InternalType.Int32) ||
             ReturnType.Equals(InternalType.Void)) &&
            match (fun_header.Parameters)
            {
              // workaround bug in MS PEVerify
              | [fp] =>
                fp.ty.Fix ().Equals (FixedType.Array (InternalType.String, 1))
              | [] => true
              | _ => false
            }
          }

          if (has_correct_signature ()) {
            if (declaring_type.TyparmsCount > 0 || !Header.TypeParameters.IsEmpty)
              Message.Warning (402, this.ToString () + ": an entry point cannot be generic or in a generic type");
            else
              match (emitter._entry_point) {
                | Some (exist) =>
                  Message.Error ($ "more than one entry point (Main function) "
                                 "found, e.g. types $(exist.DeclaringType) and $(mb.DeclaringType)");
                  Message.Hint ("you can use -main TypeName switch to disambiguate selection");
                | None =>
                  when (DeclaringType.TyManager._debug_emit != null)
                    DeclaringType.TyManager._debug_emit.SetUserEntryPoint (SymbolToken (1));
                  emitter._entry_point = Some (mb : MethodInfo)
              }
          }
          else
            Message.Warning (28, $"$this has the wrong signature to be an entry point");
        }

        // update the overriding relationships
        foreach ((overriddenType, overridden) in ImplementedMethods)
        {
          // Message.Debug("override " + method_info.Name + " " + overridden_info.Name + " in " + type_builder.FullName);
          when (!mb.IsPublic || Name != overridden.Name)
          {
            // VladD2: Возможно вместо declaring_type.GetMemType() надо использовать
            def overridden_info = ILEmitter.GetMethodInfo(overriddenType, overridden);
            type_builder.DefineMethodOverride(mb, overridden_info)
          }
        }
      }

  //    Message.Debug (this.ToString ());
      match (fun_header.body)
      {
        | FunBody.ILed => {}
        | _ =>
          // maybe create additional method for implementing interface method
          // (in case of co/contravariant methods)
          CreateImplementsWrapper();

          // Message.Debug (Location, $ "compile: $this");

          Util.locate(Location,
          {
            match (fun_header.body)
            {
              | FunBody.ILed | FunBody.Parsed => Util.ice (fun_header.body.GetType().ToString ())

              | FunBody.Typed when Message.SeenError =>
                // just skip it
                fun_header.body = FunBody.ILed ()

              | FunBody.Typed =>
                assign_parameter_indexes(GetMethodBase().IsStatic);
                emit_parameter_attributes();
                unless (declaring_type.IsDelegate)
                {
                  unless (MemberKind == MemberKinds.Constructor)
                    setup_method(declaring_type.TyManager);

                  declaring_type.DoBeforeFinalization2 (
                    fun()
                    {
                      // Message.Debug ($"making il generator for $meth");
                      def gen = ILEmitter (this);

                      when (Manager.Options.EmitDebug)
                        gen.SetDocument(Location);

                      gen.Run ();
                    });
                }

              | FunBody.Abstract => emit_parameter_attributes();
            }
          });

          when (Manager.Options.EarlyExit)
            Message.MaybeBailout ();
      }
    }

    static parameter_attributes (fp : TParameter) : ParameterAttributes
    {
      (match (fp.kind)
       {
        | ParamKind.Out => ParameterAttributes.Out
        | ParamKind.Ref
        | ParamKind.Normal => ParameterAttributes.None
       }
      )
      |
      (if (fp.default_value.IsSome)
         ParameterAttributes.HasDefault | ParameterAttributes.Optional
       else
         ParameterAttributes.None)
    }


    emit_parameter_attributes() : void
    {
      foreach (parm in fun_header.Parameters)
      {
        parm.modifiers.SaveCustomAttributes (declaring_type,
          fun(target, attr, shouldEmit)
          {
            if (target %&& System.AttributeTargets.Parameter)
            {
              when(shouldEmit)
                parm.builder.SetCustomAttribute (attr);
              null
            }
            else
              "parameter " + parm.name
          })
      }
    }


    /**
     * Assigns an ordinal index to each of a method's parameter
     */
    assign_parameter_indexes (is_static : bool) : void
    {
      mutable index = if (is_static) 0 else 1;

      foreach (parm in fun_header.Parameters)
      {
        parm.decl.SetParmIndex(index, is_by_ref = parm.kind != ParamKind.Normal);
        index++;
      }
    }


    /* build the parameter types array */
    param_types() : array[System.Type] { GetParameters().MapToArray(p => SystemHelpers.GetSystemType(p.Type)) }

    /**
     * Converts Nemerle modifiers to the CLI method attributes.
     */
    static make_method_attributes (attrs : NemerleModifiers) : MethodAttributes
    {
      mutable result = MethodAttributes.HideBySig;

      when (attrs %&& NemerleModifiers.Public)
        result |= MethodAttributes.Public;

      when (attrs %&& NemerleModifiers.Private)
        result |= MethodAttributes.Private;

      if (attrs %&& NemerleModifiers.Protected)
        if (attrs %&& NemerleModifiers.Internal)
          result |= MethodAttributes.FamORAssem;
        else
          result |= MethodAttributes.Family;
      else when (attrs %&& NemerleModifiers.Internal)
        result |= MethodAttributes.Assembly;

      when (attrs %&& NemerleModifiers.Static)
        result |= MethodAttributes.Static;

      when (attrs %&& NemerleModifiers.Override)
        result |= MethodAttributes.Virtual %| MethodAttributes.ReuseSlot;

      // when method is static, then new is only for compile-time information
      when (!(attrs %&& NemerleModifiers.Static) && attrs %&& NemerleModifiers.New && attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.NewSlot | MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Abstract)
        result |= MethodAttributes.Virtual %| MethodAttributes.Abstract;

      when (attrs %&& NemerleModifiers.Virtual)
        result |= MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.Sealed)
        result |= MethodAttributes.Final %| MethodAttributes.Virtual;

      when (attrs %&& NemerleModifiers.SpecialName)
        result |= MethodAttributes.SpecialName;

      result
    }

    /**
     * Adds a method builder to a type builder
     */
    CreateMethodBuilder (tb : Emit.TypeBuilder) : void
    {
      when (SkipEmiting)
        return;

      // Message.Debug ($"-- AddMethodBuilder: $meth $(Attributes) ");

      /* update the modifiers list */
      unless (ImplementedMethods.IsEmpty)
        Attributes |= NemerleModifiers.Virtual;

      def attrs = make_method_attributes (Attributes);
      def attrs =
        if (Name == ".cctor")
          attrs | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName
        else
          attrs;

      /* add the method to the type builder */
      mutable pinvoke = false;

      try
      {
        if (fun_header.TypeParameters.IsEmpty)
        {
          def parm_types_array = param_types ();

          method_base = Manager.AttributeCompiler.CheckPInvoking (this, tb, attrs, parm_types_array);

          if (method_base == null)
            method_base = tb.DefineMethod (Name, attrs);
          else
            pinvoke = true;
        }
        else {
          method_base = tb.DefineMethod (Name, attrs);

          def names = fun_header.TypeParameters.MapToArray(_.Name);

          def generic_parms = GetMethodBuilder().DefineGenericParameters(names);
          foreach (x in fun_header.TypeParameters with idx)
            x.SetGenericBuilder(generic_parms[idx]);
          foreach (gp in fun_header.TypeParameters)
            gp.UpdateConstraints ();
        }
      }
      catch
      {
        | e => throw System.ApplicationException (
          $"Can't define method '$Name' (attrs: $attrs) in type '$tb'.\nError: $(e.Message)", e);
      }

      GetMethodBuilder().SetSignature(
        SystemHelpers.GetSystemType(fun_header.ReturnType),
        fun_header.GetRetTypeRequiredModifiers(),
        fun_header.GetRetTypeOptionalModifiers(),
        param_types(),
        fun_header.GetParamTypeRequiredModifiers(),
        fun_header.GetParamTypeOptionalModifiers());
        
      Manager.AttributeCompiler.GetPermissionSets(Manager.CoreEnv, modifiers.custom_attrs)
        .Iter((method_base :> SRE.MethodBuilder).AddDeclarativeSecurity);

      /* add the runtime modifiers for delegate methods */
      when (DeclaringType.IsDelegate)
      {
        assert(!pinvoke);
        GetMethodBuilder().SetImplementationFlags(MethodImplAttributes.Runtime | MethodImplAttributes.Managed)
      }

      when (!pinvoke && (Attributes & NemerleModifiers.Extern != 0))
        Message.Error (Location, "method is marked `extern' but do not have DllImport attribute");

      // CompileTypedMethod.compile_parms (hd);

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.builder = GetMethodBuilder().DefineParameter (pos, parameter_attributes (p), p.name);

            match (p.default_value)
            {
              | Some(TExpr.Literal(lit)) => 
                def defaultValue = lit.AsObject(InternalType);
                def type = p.Type.Fix();
                when (defaultValue != null || !type.IsValueType)
                  p.builder.SetConstant(defaultValue);
                
              | Some(e) => Util.ice($"complex expr $e");
              | None => {}
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    /**
     * Adds a constructor builder to a type builder
     */
    CreateConstructorBuilder (tb : Emit.TypeBuilder) : void
    {
      when (SkipEmiting)
        return;

      // Message.Debug ($"-- AddConstructorBuilder: $this");

      /* create the constructor builder */
      method_base =
        tb.DefineConstructor (
          make_method_attributes (Attributes) |
          MethodAttributes.RTSpecialName |
          MethodAttributes.SpecialName,
          CallingConventions.Standard,
          param_types (),
          fun_header.GetParamTypeRequiredModifiers (),
          fun_header.GetParamTypeOptionalModifiers ());

      Manager.AttributeCompiler.GetPermissionSets(Manager.CoreEnv, modifiers.custom_attrs)
        .Iter((method_base :> SRE.ConstructorBuilder).AddDeclarativeSecurity);

      /* add the runtime modifiers for delegate constructors */
      when (DeclaringType.IsDelegate) {
        GetConstructorInfo ().SetImplementationFlags (
          MethodImplAttributes.Runtime | MethodImplAttributes.Managed
        )
      }

      def name_parms (pos, parms)
      {
        match (parms) {
          | [] => ()
          | (p : TParameter) :: ps =>
            p.builder = GetConstructorInfo ().DefineParameter (pos, parameter_attributes (p), p.name);

            match (p.default_value)
            {
              | Some(TExpr.Literal(lit)) => 
                def defaultValue = lit.AsObject(InternalType);
                def type = p.Type.Fix();
                when (defaultValue != null || !type.IsValueType)
                  p.builder.SetConstant(defaultValue);
                
              | Some(e) => Util.ice($"complex expr $e");
              | None => ()
            }
            name_parms (pos + 1, ps)
        }
      }
      name_parms (1, GetParameters ());
    }

    internal override Compile () : void
    {
      try
      {
        base.Compile ();
        RunBodyTyper ();

        when (SkipEmiting)
          return;

        when(_isConditional)
          Manager.AttributeCompiler.CheckConditional(this);

        unless (modifiers.IsEmpty)
        {
          def adder =
            if (MemberKind == MemberKinds.Constructor)
              fun (target, attribute, shouldEmit)
              {
                if (target %&& System.AttributeTargets.Constructor)
                {
                  when(shouldEmit)
                    GetConstructorInfo ().SetCustomAttribute (attribute);
                  null
                }
                else if (attribute != null)
                  "constructor " + ToString ()
                else
                  null
              }
            else
              fun (target, attribute, shouldEmit)
              {
                if (target %&& System.AttributeTargets.Method)
                {
                  when(shouldEmit)
                    GetMethodBuilder().SetCustomAttribute (attribute);
                  null
                }
                else if (attribute != null)
                  "method " + ToString ()
                else
                  null
              };

          modifiers.SaveCustomAttributes (declaring_type, adder);
        }

        unless(return_value_modifiers.IsEmpty)
        {
          return_value_modifiers.SaveCustomAttributes(declaring_type,
            fun (target, attribute, shouldEmit)
            {
              if (target %&& System.AttributeTargets.ReturnValue)
              {
                when(shouldEmit)
                {
                  def ret = GetMethodBuilder().DefineParameter (0, ParameterAttributes.None, null);
                  ret.SetCustomAttribute (attribute);
                }
                null
              }
              else if (attribute != null)
                "method " + ToString ()
              else
                null
            });
        }

        CompileAfterTyping()
      }
      catch { | _ is Typer.IllegalYieldReturnType => () }
    }
  }
}
