using Nemerle.Collections;
using Nemerle.Compiler.Backend;
using Nemerle.Compiler.Typedtree;
using Nemerle.Utility;

using DN = dnlib.DotNet;

namespace Nemerle.Compiler
{
  [ManagerAccess]
  class SignatureBuilder
  {
    public this(manager : ManagerClass)
    {
      Manager         = manager;
    }

    public GetMethodInfo(from_type : TypeVar, meth : IMethod, typars : list [TypeVar]) : DN.IMethod
    {
      def system_from_type = ToSuperTypeSig(from_type, meth.DeclaringType);
      mutable result = system_from_type.MakeMethodRef(meth);
      unless (typars.IsEmpty)
      {
        def m_typarms = meth.GetHeader().TypeParameters;
        def errorCount = Message.ErrorCount;
        NList.Iter2 (m_typarms, typars, _.CheckConstraints (_, meth));
        when (errorCount == Message.ErrorCount)
        {
          def pars  = typars.MapToArray(t => SystemHelpers.ToBackendType(t.Fix(), from_type.InternalType.Object_tc).TypeSig);
          result = DN.MethodSpecUser(result :> DN.IMethodDefOrRef, DN.GenericInstMethodSig(pars));
        }
      }
      result
    }

    public GetFieldInfo(from_type : TypeVar, field : IField) : DN.IField
    {
      def obj_type = ToSuperTypeSig(from_type, field.DeclaringType);
      obj_type.MakeFieldRef(field)
    }
    
    private static ToSuperTypeSig(type : TypeVar, superType : TypeInfo) : IBackendType
    {
      def type = type.Fix();
      (if (type is FixedType.Tuple) type else type.GetInstantiatedSuperType(superType)).ToBackendType()
    }
  } // end of the class
} // end of the namespace
