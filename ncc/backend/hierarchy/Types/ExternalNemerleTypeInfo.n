using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler.Typedtree;
using Nemerle.IO;
using Nemerle.Late;
using Nemerle.Utility;
using System.IO;

using PT = Nemerle.Compiler.Parsetree;
using SR = System.Reflection;
using SRE = System.Reflection.Emit;
using SCG = System.Collections.Generic;

namespace Nemerle.Compiler
{
  internal class ExternalNemerleTypeInfo : ExternalTypeInfo
  {
    tydecl          : TypeDeclaration;
    constant_object : IField;

    public this (lib : LibraryReference, h : System.Type, ns_node : NamespaceTree.Node)
    {
      base(lib, h, ns_node);

      if (system_type.IsDefined(SystemTypeCache.VariantAttribute, false))
      {
        def names =
        {
          def attr = system_type.GetCustomAttributes(SystemTypeCache.VariantAttribute, false)[0];
          NString.Split(late(attr.VariantOptions) :> string, array [','])
        };
        def get_opt (name : string, index : int)
        {
          match (lib.LibRefManager.NameTree.LookupExactType(NString.Split (name, array ['.', '+'])))
          {
            | Some (tc is ExternalNemerleTypeInfo) =>
              tc.VariantOptionCode = index;
              tc
            | Some => assert(false);

            | None =>
              if (lib.LibRefManager.IsAssemblyLoaded(system_type.Assembly.FullName))
              {
                System.Diagnostics.Debug.Assert(false);
                Util.ice($"cannot find variant option named $name")
              }
              else //Требует перевода: Тип может быть не загружен в следствии того, что на библиотеку
              {    // не было ссылки в проекте. Загружаем библиотеку и пробуем повторить операци. Возможно это не лучшее решение!
                lib.LibRefManager.AddAssembly(system_type.Assembly, false);
                lib.LibRefManager.LoadLibrariesContents();
                get_opt(name, index)
              }
          }
        }

        mutable variantOptions = [];
        mutable index = 0;
        foreach(name in names)
        {
          variantOptions ::= get_opt(name, index);
          ++index;
        }

        tydecl = TypeDeclaration.Variant (variantOptions.Rev());
      }
      else if (system_type.IsDefined (SystemTypeCache.VariantOptionAttribute, false))
        tydecl = TypeDeclaration.VariantOption();
      else if (system_type.IsDefined (SystemTypeCache.ConstantVariantOptionAttribute, false))
      {
        tydecl = TypeDeclaration.VariantOption ();

        match (LookupMember ("_N_constant_object"))
        {
          | [fld] => constant_object = fld :> IField
          | _     => Util.ice ("cannot find _N_constant_object")
        }
      }
      else if (system_type.IsDefined (SystemTypeCache.TypeAliasAttribute, false))
      {
        def aliasedType =
        {
          def attr = system_type.GetCustomAttributes(SystemTypeCache.TypeAliasAttribute, false)[0];
          late(attr.AliasedType) :> string
        };
        tydecl = TypeDeclaration.Alias(TyCodec.DecodeType (lib, tenv, aliasedType))
      }
      else if (system_type.IsInterface)
        tydecl = TypeDeclaration.Interface()
      else if (system_type.IsEnum)
        tydecl = TypeDeclaration.Enum()
      else
        tydecl = TypeDeclaration.Class();

      decode_extension_patterns();
    }
    //TODO: ValdD2: Rename this
    public override GetTydecl()         : TypeDeclaration { tydecl }
    public override GetConstantObject() : IField          { constant_object }

    decode_extension_patterns () : void
    {
      def t = SystemTypeCache.ExtensionPatternEncodingAttribute;
      def attrs = system_type.GetCustomAttributes (t, false);

      when (attrs.Length > 0)
      {
        def get_ids  = t.GetMethod ("get_Identifiers");
        def get_pat  = t.GetMethod ("get_Pattern");
        def get_name = t.GetMethod ("get_Name");

        foreach (attr_obj in attrs)
        {
          def ids = get_ids.Invoke (attr_obj, null) :> string;
          def pat = get_pat.Invoke (attr_obj, null) :> string;
          def name = get_name.Invoke (attr_obj, null) :> string;
          def ext = ExtensionPattern (parent      = this,
                                      identifiers = NString.Split (ids, [',']),
                                      pattern     = MainParser.ParseExpr (Manager.CoreEnv, pat),
                                      name        = name,
                                      temporary   = false);

          AddExtensionPattern (ext);
        }
      }
    }
  }
} /* namespace */
