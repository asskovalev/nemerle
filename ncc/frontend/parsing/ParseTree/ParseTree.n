using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Utility;

using System.Diagnostics;

using T = Nemerle.Compiler.Typedtree;

namespace Nemerle.Compiler.Parsetree
{
  /// implemented by parse tree and typed tree function headers
  public interface IParametersProvider
  {
    ParametersDeclarations : list [PParameter] { get; }
    ParametersReferences : list [PExpr] { get; }
  }

  public class PFunHeader : ParsedBase, IParametersProvider
  {
    public   mutable TypeParameters : TypePparms;
    public   mutable SplicableName  : Splicable; // is changed when typing lambda
    public   mutable ReturnType     : PExpr;
    public   mutable Parameters     : list[PParameter];

    public new TypedObject : T.TFunHeader { get { base.TypedObject :> T.TFunHeader } }

    // Values of following properties don't changing while typing process.

    public ParsedTypeParameters          : TypePparms;
    public ParsedSplicableName           : Splicable;
    public ParsedReturnType              : PExpr;
    public ParsedParameters              : list[PParameter];
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersOpenLocation  : Location;
    [Accessor(flags=WantSetter), RecordIgnore] internal mutable _parsedParametersCloseLocation : Location;

    public this(loc : Location, name : Splicable, returnType : PExpr, parameters : list [PParameter])
    {
      this(loc, TypePparms.Empty, name, returnType, parameters);
    }

    public this(typeParameters : TypePparms, name : Splicable, returnType : PExpr, parameters : list [PParameter])
    {
      this(LocationStack.Top(), typeParameters, name, returnType, parameters)
    }

    public this(
      loc                     : Location,
      typeParameters          : TypePparms,
      name                    : Splicable,
      returnType              : PExpr,
      parameters              : list [PParameter]
    )
    {
      this(loc, typeParameters, name, returnType, parameters, Location.Default, Location.Default)
    }

    public this(
      loc                     : Location,
      typeParameters          : TypePparms,
      name                    : Splicable,
      returnType              : PExpr,
      parameters              : list [PParameter],
      parametersOpenLocation  : Location,
      parametersCloseLocation : Location,
    )
    {
      base(loc);
      ParsedTypeParameters           = typeParameters;
      ParsedSplicableName            = name;
      ParsedParameters               = parameters;
      ParsedReturnType               = returnType;
      TypeParameters                 = typeParameters;
      SplicableName                  = name;
      Parameters                     = parameters;
      ReturnType                     = returnType;
      _parsedParametersOpenLocation  = parametersOpenLocation;
      _parsedParametersCloseLocation = parametersCloseLocation;
    }

    public Name : string { get { ParsedSplicableName.ToString() } }

    public PName : Name { get { SplicableName.GetName() } }

    private ParametersDeclarations : list[PParameter] implements IParametersProvider.ParametersDeclarations
    { get { Parameters } }

    public ParametersReferences : list [PExpr]        implements IParametersProvider.ParametersReferences
    { get { Parameters.Map(_.ReferencingExpr) } }

    public GetTypeReferences() : Seq[PExpr]
    {
      yield ReturnType;
      
      foreach (p in Parameters)
        foreach (x in p.GetTypeReferences())
          yield x;
    }
    
    public override ToString() : string
    {
      $"$Name$TypeParameters(..$Parameters) : $ReturnType"
    }
  }

  public class Function_decl : ParsedBase
  {
    public this(header : PFunHeader, body : PExpr)
    {
      mutable loc;

      when (header != null)
        loc = header.Location;

      when (body != null)
        loc += body.Location;

      this(loc, header, body);
    }

    public this(location : Location, header : PFunHeader, body : PExpr)
    {
      base(location);
      this.header = header;
      this.body   = body;
    }

    public         header : PFunHeader;
    public mutable body   : PExpr;
  }

  [Record]
  public class MatchCase : ParsedBase
  {
    public this(patterns : list [PExpr], body : PExpr)
    {
      this(patterns, body, false)
    }

    public this(patterns : list [PExpr], body : PExpr, patternsLocation : Location, arrowLocation : Location)
    {
      this(patterns, body, false);
      _patternsLocation = patternsLocation;
      _arrowLocation    = arrowLocation;
    }

    public patterns : list [PExpr];
    public body : PExpr;
    public mutable disable_warnings : bool;

    [RecordIgnore, Accessor] mutable _patternsLocation : Location;
    [RecordIgnore, Accessor] mutable _arrowLocation    : Location;
    public BodyLocation     : Location { get { body.Location } }

    public override Location : Location
    {
      get
      {
        mutable loc = body.Location;

        patterns.Iter(p => loc = loc.Combine(p.Location));

        loc;
      }
    }

    public override ToString() : string
    {
      $"| $(patterns.ToString(\" | \")) => $body"
    }
  }

  [Record]
  public variant TryCase : ParsedBase
  {
    | Catch    { exn : Splicable; exn_ty : PExpr; handler : PExpr; }
    | Filter   { exn : Splicable; exn_ty : PExpr; filter : PExpr; handler : PExpr; }
    | Ellipsis { body : PExpr; }

    public new TypedObject : T.TryCase { get { base.TypedObject :> T.TryCase } }
  }

  public variant SyntaxElement
  {
    | Expression       { body : PExpr; }
    | MatchCase        { body : Parsetree.MatchCase; }
    | Function         { body : Function_decl; }
    | Parameter        { body : PParameter; }
    | TType            { body : PExpr; }

    | RawToken         { body : Token; }

    | ClassMember      { body : Parsetree.ClassMember; }
    | TypeBuilder      { body : Compiler.TypeBuilder; }
    | FieldBuilder     { body : Compiler.FieldBuilder; }
    | MethodBuilder    { body : Compiler.MethodBuilder; }
    | PropertyBuilder  { body : Compiler.PropertyBuilder; }
    | EventBuilder     { body : Compiler.EventBuilder; }
    | ParameterBuilder { body : Typedtree.TParameter; }

    public Location : Location
    {
      get
      {
        match (this)
        {
          | Expression(null)    | Parameter(null)        | TType(null)
          | ClassMember(null)   | ParameterBuilder(null) | FieldBuilder(null)
          | MethodBuilder(null) | PropertyBuilder (null) | EventBuilder(null)
          | MatchCase(null)     | Function(null)         | RawToken(null)
          | TypeBuilder(null)                      => Location.Default;

          | Expression       (body : Located)
          | Parameter        (body : Located)
          | TType            (body : Located)
          | ClassMember      (body : Located)
          | ParameterBuilder (body : Located)       => body.Location;
          | FieldBuilder     (body : MemberBuilder)
          | MethodBuilder    (body : MemberBuilder)
          | PropertyBuilder  (body : MemberBuilder)
          | EventBuilder     (body : MemberBuilder) => body.Location;
          | MatchCase        (body)                 => body.Location;
          | Function         (body)                 => body.Location;
          | RawToken         (body)                 => body.Location;
          | TypeBuilder      (body)                 => body.Location;
        }
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | SyntaxElement.Expression(null) => ""
        | SyntaxElement.Expression(body) => body.ToString()
        | SyntaxElement.TType(body)      => "ttype: " + body.ToString()
        | SyntaxElement.RawToken(t)      => t.ToString()
        | SyntaxElement.MatchCase        => "match case"
        | SyntaxElement.Function         => "function"
        | SyntaxElement.Parameter        => "parameter"
        | SyntaxElement.ClassMember      => "ClassMember"
        | SyntaxElement.TypeBuilder      => "TypeBuilder"
        | SyntaxElement.FieldBuilder     => "FieldBuilder"
        | SyntaxElement.MethodBuilder    => "MethodBuilder"
        | SyntaxElement.PropertyBuilder  => "PropertyBuilder"
        | SyntaxElement.EventBuilder     => "EventBuilder"
        | SyntaxElement.ParameterBuilder => "ParameterBuilder"
      }
    }
  }
} // namespace
