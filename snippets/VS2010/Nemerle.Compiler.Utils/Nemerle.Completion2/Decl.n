using Nemerle.Compiler;
using Nemerle.Compiler.Utils;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System.Collections.Generic;

namespace Nemerle.Completion2
{
  [Record]
  public variant Decl
  {
    | GlobalAttribute { }
    | Using
      {
                Name          : list[string];
        mutable NameLocations : list[Location];
                Alias         : string;
        mutable AliasLocation : Location;
                BeforeEnv     : GlobalEnv;
                AfterEnv      : GlobalEnv;

        public Compare(other : Using) : AstComparison
        {
          if (other.Name.Equals(Name) && other.Alias == Alias)
            AstComparison.Identical()
          else
            AstComparison.Different()
        }
      }
    | Namespace
      {
        mutable Decls                  : list[Decl];
                Name                   : list[string];
        mutable NameLocations          : list[Location]; // mutable need for Relocation algorithm
                OutsideEnv             : GlobalEnv;
                InsideEnv              : GlobalEnv;
                Source                 : SourceSnapshot;
        mutable HeaderLocation         : Location;
        mutable BodyOpenTokenLocation  : Location;
        mutable BodyCloseTokenLocation : Location;
        /// TopDeclaration-s of file. Exists only in top namespace.
                TopDeclarations        : list[TopDeclaration];

        /// The Location contains only body (without braces location)
        public BodyLocation  : Location
        {
          get
          {
            def loc = BodyOpenTokenLocation;
            def end = BodyCloseTokenLocation;
            if (end == Location.Default) loc // parsing of ns body failed!
            else Location(loc.FileIndex, loc.EndLine, loc.EndColumn, end.Line, end.Column)
          }
        }

        public Compare(other : Namespace) : AstComparison
        {
          unless (other.Name.Equals(Name))
            return AstComparison.Different();
            
          unless (Decls.Length != other.Decls.Length)
            return AstComparison.Different();
            
          def e1          = Decls.GetEnumerator();
          def e2          = other.Decls.GetEnumerator();
          def diffMembers = List();
          
          while (e1.MoveNext() && e2.MoveNext())
          {
            match (e1.Current.Compare(e2.Current))
            {
              | Different                        => return AstComparison.Different()
              | Identical                        => ()
              | DifferentInMemberBodies(members) => diffMembers.AddRange(members);
            }
          }
          
          if (diffMembers.Count == 0)
            AstComparison.Identical()
          else
            AstComparison.DifferentInMemberBodies(diffMembers);
        }
      }
    | Type
      {
        Ast              : TopDeclaration;

        public Compare(other : Type) : AstComparison
        {
          Compare(Ast, other.Ast)
        }
      }
    | None

    public Compare(other : Decl) : AstComparison
    {
      match (other, this)
      {
        | (Using     as x1, Using     as x2) => x1.Compare(x2)
        | (Namespace as x1, Namespace as x2) => x1.Compare(x2)
        | (Type as x1,           Type as x2) => x1.Compare(x2)
        | (GlobalAttribute, GlobalAttribute) => AstComparison.Identical() // TODO: Fix it
        | (None,                       None) => AstComparison.Identical()
        | (null,                       null) => AstComparison.Identical()
        | _                                  => AstComparison.Different()
      }
    }

    [Accessor (flags = WantSetter)]
    mutable _location : Location;

    public override ToString() : string
    {
      match (this)
      {
        | GlobalAttribute   => "<attribute>"
        | Using     as decl => "using " + decl.Name.ToString(".") + ";"
        | Namespace as decl => "namespace " + decl.Name.ToString(".") + " { ... }"
        | None              => "<none>"
        | Type(typeBuilder) => typeBuilder.ToString()
      }
    }

    /// Finds the innermost top level construction (namespace, class,
    /// using, attribute) located at line, and col.
    public FindDecl(at : Location) : Decl
    {
      def find_decl(decl : Decl)
      {
        def find(decls : list[Decl])
        {
          | decl2 :: tail =>
            match (find_decl(decl2))
            {
              | Decl.None => find(tail)
              | x         => x
            }
          | [] => decl
        }

        match (decl)
        {
          | Decl.Namespace as ns2 when ns2.Location.Contains(at) => find(ns2.Decls)
          | Decl.Using     as usn when usn.Location.Contains(at) => decl
          | Decl.Type(ast)        when ast.Location.Contains(at) => decl
          | _                                                    => Decl.None(Location.Default)
        }
      }

      find_decl(this)
    }
    
    private Compare(a : PExpr, b : PExpr) : bool
    {
      true
    }
    
    private Compare(a : ParsedBase, b : ParsedBase) : AstComparison
    {
      | (DeclarationBase as x, DeclarationBase as y) =>
        unless (x.name.Equals(y.name))
          return AstComparison.Different();

        def am1 = x.modifiers;
        def am2 = y.modifiers;
        unless (am1.custom_attrs.ForAll2(am2.custom_attrs, Compare))
          return AstComparison.Different();
        unless (am1.mods == am2.mods)
          return AstComparison.Different();
        unless (am1.GetMacroAttributes().ForAll2(am2.GetMacroAttributes(), Compare))
          return AstComparison.Different();
          
        match (x, y)
        {
          | (TopDeclaration as td1, TopDeclaration as td2) =>
            match (x, y)
            {
              | (TopDeclaration.Alias         as a1, TopDeclaration.Alias         as a2) => 
              | (TopDeclaration.Class         as c1, TopDeclaration.Class         as c2) => 
              | (TopDeclaration.Delegate      as d1, TopDeclaration.Delegate      as d2) => 
              | (TopDeclaration.Enum          as e1, TopDeclaration.Enum          as e2) => 
              | (TopDeclaration.Interface     as i1, TopDeclaration.Interface     as i2) => 
              | (TopDeclaration.Macro         as m1, TopDeclaration.Macro         as m2) => 
              | (TopDeclaration.Variant       as v1, TopDeclaration.Variant       as v2) => 
              | (TopDeclaration.VariantOption as o1, TopDeclaration.VariantOption as o2) => 
              | _                                                                        => false
            }
          
        }
          //| (TopDeclaration.Class as x, TopDeclaration.Class as y) => x.
      
      | _ => false
    }
  }
}
