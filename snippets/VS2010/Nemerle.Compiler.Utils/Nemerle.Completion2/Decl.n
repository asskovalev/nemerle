using Nemerle.Compiler;
using Nemerle.Compiler.Utils;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Completion2
{
  [Record]
  public variant Decl
  {
    | GlobalAttribute { }
    | Using
      {
                Name          : list[string];
        mutable NameLocations : list[Location];
                Alias         : string;
        mutable AliasLocation : Location;
                BeforeEnv     : GlobalEnv;
                AfterEnv      : GlobalEnv;

        public Compare(other : Using) : AstComparison
        {
          if (other.Name.Equals(Name) && other.Alias == Alias)
            AstComparison.Identical()
          else
            AstComparison.Different()
        }
      }
    | Namespace
      {
        mutable Decls                  : list[Decl];
                Name                   : list[string];
        mutable NameLocations          : list[Location]; // mutable need for Relocation algorithm
                OutsideEnv             : GlobalEnv;
                InsideEnv              : GlobalEnv;
                Source                 : SourceSnapshot;
        mutable HeaderLocation         : Location;
        mutable BodyOpenTokenLocation  : Location;
        mutable BodyCloseTokenLocation : Location;
        /// TopDeclaration-s of file. Exists only in top namespace.
                TopDeclarations        : list[TopDeclaration];

        /// The Location contains only body (without braces location)
        public BodyLocation  : Location
        {
          get
          {
            def loc = BodyOpenTokenLocation;
            def end = BodyCloseTokenLocation;
            if (end == Location.Default) loc // parsing of ns body failed!
            else Location(loc.FileIndex, loc.EndLine, loc.EndColumn, end.Line, end.Column)
          }
        }

        public Compare(other : Namespace) : AstComparison
        {
          unless (other.Name.Equals(Name))
            return AstComparison.Different();

          unless (Decls.Length != other.Decls.Length)
            return AstComparison.Different();

          def e1          = Decls.GetEnumerator();
          def e2          = other.Decls.GetEnumerator();
          def diffMembers = List();

          while (e1.MoveNext() && e2.MoveNext())
          {
            match (e1.Current.Compare(e2.Current))
            {
              | Different                        => return AstComparison.Different()
              | Identical                        => ()
              | DifferentInMemberBodies(members) => diffMembers.AddRange(members);
            }
          }

          if (diffMembers.Count == 0)
            AstComparison.Identical()
          else
            AstComparison.DifferentInMemberBodies(diffMembers);
        }
      }
    | Type
      {
        Ast              : TopDeclaration;

        public Compare(other : Type) : AstComparison
        {
          Compare(Ast, other.Ast)
        }
      }
    | None

    public Compare(other : Decl) : AstComparison
    {
      match (other, this)
      {
        | (Using     as x1, Using     as x2) => x1.Compare(x2)
        | (Namespace as x1, Namespace as x2) => x1.Compare(x2)
        | (Type as x1,           Type as x2) => x1.Compare(x2)
        | (GlobalAttribute, GlobalAttribute) => AstComparison.Identical() // TODO: Fix it
        | (None,                       None) => AstComparison.Identical()
        | (null,                       null) => AstComparison.Identical()
        | _                                  => AstComparison.Different()
      }
    }

    [Accessor (flags = WantSetter)]
    mutable _location : Location;

    public override ToString() : string
    {
      match (this)
      {
        | GlobalAttribute   => "<attribute>"
        | Using     as decl => "using " + decl.Name.ToString(".") + ";"
        | Namespace as decl => "namespace " + decl.Name.ToString(".") + " { ... }"
        | None              => "<none>"
        | Type(typeBuilder) => typeBuilder.ToString()
      }
    }

    /// Finds the innermost top level construction (namespace, class,
    /// using, attribute) located at line, and col.
    public FindDecl(at : Location) : Decl
    {
      def find_decl(decl : Decl)
      {
        def find(decls : list[Decl])
        {
          | decl2 :: tail =>
            match (find_decl(decl2))
            {
              | Decl.None => find(tail)
              | x         => x
            }
          | [] => decl
        }

        match (decl)
        {
          | Decl.Namespace as ns2 when ns2.Location.Contains(at) => find(ns2.Decls)
          | Decl.Using     as usn when usn.Location.Contains(at) => decl
          | Decl.Type(ast)        when ast.Location.Contains(at) => decl
          | _                                                    => Decl.None(Location.Default)
        }
      }

      find_decl(this)
    }

    ///////////////////////////////////////////////////

    private CompareClassMember(a : ClassMember, b : ClassMember) : AstComparison
    {
      AstComparison.Different()
    }

    private ComparePExprs(a : list[PExpr], b : list[PExpr]) : bool
    {
      a.ForAll2(b, ComparePExpr)
    }

    private CompareClassMembers(member1 : list[ClassMember], member2 : list[ClassMember]) : AstComparison
    {
      def loop(ms1 : list[ClassMember], ms2 : list[ClassMember], diffs : List[ClassMember]) : bool
      {
        match (ms1, ms2)
        {
          | ([], []) => true
          | (m1 :: tail1, m2 :: tail2)  =>
            match (CompareClassMember(m1, m2))
            {
              | Different => false
              | Identical => loop(tail1, tail2, diffs)
              | DifferentInMemberBodies(diffs2) => diffs.AddRange(diffs2); true
            }
          | _ => false
        }
      }

      def diffs = List();

      unless (loop(member1, member2, diffs))
        return AstComparison.Different();

      if (diffs.Any())
        AstComparison.DifferentInMemberBodies(diffs)
      else
        AstComparison.Identical()
    }

    CompareConstraint(c1 : Constraint, c2 : Constraint) : bool
    {
      unless (c1.tyvar.Equals(c2.tyvar))
        return false;

      unless (ComparePExpr(c1.ty, c2.ty))
        return false;

      c1.IsSpecial == c2.IsSpecial
    }

    CompareConstraints(cs1 : list[Constraint], cs2 : list[Constraint]) : bool
    {
      cs1.ForAll2(cs2, CompareConstraint)
    }

    CompareTypeParameters(p1 : TypePparms, p2 : TypePparms) : bool
    {
      unless (p1.tyvars.Equals(p2.tyvars))
        return false;

      unless (CompareConstraints(p1.constraints, p2.constraints))
        return false;

      true
    }

    ComparePParameter(parameter1 : PParameter, parameter2 : PParameter) : bool
    {
      unless (CompareDeclarationBase(parameter1, parameter1))
        return false;

      unless (ComparePExpr(parameter1.ParsedType, parameter1.ParsedType))
        return false;

      unless (ComparePExpr(parameter1.ParsedPatternHack, parameter1.ParsedPatternHack))
        return false;

      match (parameter1.ParsedDefaultValue, parameter2.ParsedDefaultValue)
      {
        | (Some(e1), Some(e2)) => ComparePExpr(e1, e2)
        | (None,     None)     => true
        | _                    => false
      }
    }

    ComparePParameters(parameters1 : list[PParameter], parameters2 : list[PParameter]) : bool
    {
      parameters1.ForAll2(parameters2, ComparePParameter)
    }

    ComparePFunHeader(header1 : PFunHeader, header2 : PFunHeader) : bool
    {
      unless (header1.SplicableName.Equals(header2.SplicableName))
        return false;

      unless (CompareTypeParameters(header1.TypeParameters, header2.TypeParameters))
        return false;

      unless (ComparePExpr(header1.ReturnType, header2.ReturnType))
        return false;

      unless (ComparePParameters(header1.Parameters, header2.Parameters))
        return false;

      true
    }

    Compare(am1 : AttributesAndModifiers, am2 : AttributesAndModifiers) : bool
    {
      unless (ComparePExprs(am1.custom_attrs, am2.custom_attrs))
        return false;
      unless (am1.mods == am2.mods)
        return false;
      unless (ComparePExprs(am1.GetMacroAttributes(), am2.GetMacroAttributes()))
        return false;
      true
    }

    CompareDeclarationBase(x : DeclarationBase, y : DeclarationBase) : bool
    {
        unless (x.ParsedSplicableName.Equals(y.ParsedSplicableName))
          return false;

        unless (Compare(x.ParsedAttributsAndModifiers, y.ParsedAttributsAndModifiers))
          return false;

        true
    }

    private Compare(a : ParsedBase, b : ParsedBase) : AstComparison
    {
      | (DeclarationBase as x, DeclarationBase as y) =>
        unless (CompareDeclarationBase(x, y))
          return AstComparison.Different();

        match (x, y)
        {
          | (TopDeclaration as td1, TopDeclaration as td2) =>
            match (td1, td2)
            {
              | (TopDeclaration.Alias         as a1, TopDeclaration.Alias         as a2) =>
                if (ComparePExpr(a1.ty, a2.ty))
                  AstComparison.Identical()
                else
                  AstComparison.Different()

             | (TopDeclaration.Delegate      as d1, TopDeclaration.Delegate      as d2) =>
                unless (Compare(d1.ReturnValueModifiers, d2.ReturnValueModifiers))
                  return AstComparison.Different();

                if (ComparePFunHeader(d1.header, d2.header))
                  AstComparison.Identical()
                else
                  AstComparison.Different()

              | (TopDeclaration.Variant(  t_extends=extends1, decls=decls1),   TopDeclaration.Variant(  t_extends=extends2, decls=decls2))
              | (TopDeclaration.Enum(     t_extends=extends1, decls=decls1),   TopDeclaration.Enum(     t_extends=extends2, decls=decls2))
              | (TopDeclaration.Class(    t_extends=extends1, decls=decls1),   TopDeclaration.Class(    t_extends=extends2, decls=decls2))
              | (TopDeclaration.Interface(t_extends=extends1, methods=decls1), TopDeclaration.Interface(t_extends=extends2, methods=decls2)) =>
                unless (ComparePExprs(extends1, extends2))
                  return AstComparison.Different();

                CompareClassMembers(decls1, decls2)

              | (TopDeclaration.Macro         as m1, TopDeclaration.Macro         as m2) =>
                unless (ComparePFunHeader(m1.header, m2.header))
                  return AstComparison.Different();

                if (ComparePExprs(m1.synt, m1.synt) && ComparePExpr(m1.expr, m1.expr))
                  AstComparison.Identical()
                else
                  AstComparison.Different()

              | (TopDeclaration.VariantOption as o1, TopDeclaration.VariantOption as o2) => CompareClassMembers(o1.decls, o2.decls)
              | _                                                                        => AstComparison.Different()
            }
          | _ => AstComparison.Different()
        }

      | (PFunHeader as fh1, PFunHeader as fh2) when ComparePFunHeader(fh1, fh2) => AstComparison.Identical()
      | _ => AstComparison.Different()
    }
    
    private CompareName(a : Name, b : Name) : bool
    {
      a.idl == b.idl
    }
    
    private CompareSplicable(a : Splicable, b : Splicable) : bool
    {
      | (Name as x,       Name as y)       => CompareName(x.body, y.body)
      | (Expression as x, Expression as y) => ComparePExpr(x.expr, y.expr)
      | (HalfId as x,     HalfId as y)     => CompareName(x.prefix, y.prefix)
      | _ => false
    }
    
    private CompareTryCase(a : TryCase, b : TryCase) : bool
    {
      | (Catch    as x, Catch    as y) => CompareSplicable(x.exn, y.exn) && ComparePExpr(x.exn_ty, y.exn_ty) && ComparePExpr(x.handler, y.handler)
      | (Filter   as x, Filter   as y) => CompareSplicable(x.exn, y.exn) && ComparePExpr(x.exn_ty, y.exn_ty) && ComparePExpr(x.handler, y.handler) && ComparePExpr(x.filter, y.filter)
      | (Ellipsis as x, Ellipsis as y) => ComparePExpr(x.body, y.body)
      | _ => false
    }
    
    private CompareLiteral(a : Literal, b : Literal) : bool
    {
      a.Equals(b)
    }

    private ComparePExprOpt(a : option[PExpr], b : option[PExpr]) : bool
    {
      | (Some(x), Some(y)) => ComparePExpr(x, y)
      | (None, None) => true
      | _ => false
    }
    
    private ComparePMatchCase(a : PMatchCase, b : PMatchCase) : bool
    {
      ComparePExpr(a.body, b.body) && ComparePExprs(a.patterns, b.patterns) && a.disable_warnings == b.disable_warnings
    }
    
    private CompareFunctionDecl(a : FunctionDecl, b : FunctionDecl) : bool
    {
      ComparePExpr(a.body, b.body) && ComparePFunHeader(a.header, b.header) && CompareToken(a.FirstToken, b.FirstToken)
    }
    
    private CompareToken(a : Token, b : Token) : bool
    {
    }
    
    private CompareSyntaxElement(a : SyntaxElement, b : SyntaxElement) : bool
    {
    }
    
    private ComparePExpr(a : PExpr, b : PExpr) : bool
    {
      | (Wildcard             , Wildcard             ) => true
      | (Void                 , Void                 ) => true
      | (Ref              as x, Ref              as y) => CompareName(x._name, y._name)
      | (Is               as x, Is               as y) => ComparePExpr(x.pat, y.pat) && ComparePExpr(x.ty, y.ty)
      | (As               as x, As               as y) => ComparePExpr(x.pat, y.pat) && CompareSplicable(x.name, y.name)
      | (Where            as x, Where            as y) => ComparePExpr(x.fields, y.fields)
      | (Member           as x, Member           as y) => ComparePExpr(x.obj, y.obj) && CompareSplicable(x.member, y.member)
      | (Call             as x, Call             as y) => ComparePExpr(x.func, y.func) && ComparePExprs(x.parms, y.parms)
      | (GenericSpecifier as x, GenericSpecifier as y) => ComparePExpr(x.func, y.func) && ComparePExprs(x.generic_parms, y.generic_parms)
      | (ListLiteral      as x, ListLiteral      as y) => ComparePExprs(x.elements, y.elements)
      | (Assign           as x, Assign           as y) => ComparePExpr(x.target, y.target) && ComparePExpr(x.source, y.source)
      | (DefMutable       as x, DefMutable       as y) => ComparePExpr(x.name, y.name) && ComparePExpr(x.val, y.val)
      | (Define           as x, Define           as y) => ComparePExpr(x.pattern, y.pattern) && ComparePExpr(x.val, y.val)
      | (Throw            as x, Throw            as y) => ComparePExpr(x.exn, y.exn)
      | (Try              as x, Try              as y) => ComparePExpr(x.body, y.body) && x.cases.ForAll2(y.cases, CompareTryCase)
      | (TryFinally       as x, TryFinally       as y) => ComparePExpr(x.body, y.body) && ComparePExpr(x.handler, y.handler)
      | (Literal          as x, Literal          as y) => CompareLiteral(x.val, y.val)
      | (This                 , This                 ) => true
      | (Base             as x, Base             as y) => ComparePExprOpt(x.ty, y.ty)
      | (Typeof           as x, Typeof           as y) => ComparePExpr(x.ty, y.ty)
      | (TypeConversion   as x, TypeConversion   as y) => ComparePExpr(x.expr, y.expr) && ComparePExpr(x.ty, y.ty)
      | (TypeEnforcement  as x, TypeEnforcement  as y) => ComparePExpr(x.expr, y.expr) && ComparePExpr(x.ty, y.ty)
      | (Sequence         as x, Sequence         as y) => ComparePExprs(x.body, y.body)
      | (Tuple            as x, Tuple            as y) => ComparePExprs(x.args, y.args)
      | (Array            as x, Array            as y) => ComparePExpr(x.rank, y.rank) && ComparePExpr(x.args, y.args)
      | (EmptyArray       as x, EmptyArray       as y) => ComparePExprs(x.sizes, y.sizes)
      | (Indexer          as x, Indexer          as y) => ComparePExpr(x.obj, y.obj) && ComparePExprs(x.args, y.args)
      | (ParmByRef        as x, ParmByRef        as y) => ComparePExpr(x.parm, y.parm)
      | (ParmOut          as x, ParmOut          as y) => ComparePExpr(x.parm, y.parm)
      | (Error                , Error                ) => true
      | (Spliced          as x, Spliced          as y) => ComparePExpr(x.body, y.body)
      | (ToComplete       as x, ToComplete       as y) => CompareName(x.body, y.body)
      | (Ellipsis         as x, Ellipsis         as y) => ComparePExpr(x.body, y.body)
      | (Match            as x, Match            as y) => ComparePExpr(x.expr, y.expr) && x.cases.ForAll2(y.cases, ComparePMatchCase)
      | (DefFunctions     as x, DefFunctions     as y) => x.funs.ForAll2(y.funs, CompareFunctionDecl)
      | (Lambda           as x, Lambda           as y) => CompareFunctionDecl(x.decl, y.decl)
      | (Quoted           as x, Quoted           as y) => CompareSyntaxElement(x.body, y.body)
      | (MacroCall        as x, MacroCall        as y) => CompareName(x.name, y.name) && x.parms.ForAll2(y.parms, CompareSyntaxElement) // ns ??
      | (Typed                , Typed                ) => true
      | (TypedPattern         , TypedPattern         ) => true
      | (TypedType            , TypedType            ) => true
    }
  }
}
