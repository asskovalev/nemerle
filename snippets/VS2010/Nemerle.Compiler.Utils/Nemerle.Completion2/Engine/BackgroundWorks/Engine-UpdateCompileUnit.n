using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Utility;
using Nemerle.Compiler.Utils;
using Nemerle.Compiler.Utils.Async;
using Nemerle.Surround;

[assembly: DefineSurround("currentAsyncRequest", false,
                          _currentAsyncRequest = request,
                          {
                            _currentAsyncRequest = null;
                          })]


namespace Nemerle.Completion2
{
  using MethodBuilderEx = Factories.IntelliSenseModeMethodBuilder;

  internal partial class Engine
  {
    public LastEditTime : DateTime { get; private set; }

    public BeginUpdateCompileUnit(ideSource : IIdeSource, changes : IChanges) : AsyncRequest
    {
      LastEditTime = DateTime.Now;
      def request = UpdateCompileUnitAsyncRequest(this, ideSource, changes, UpdateCompileUnit);
      AsyncWorker.AddWork(request);
      request
    }

    private TryRelocate(source : IIdeSource, changes : IChanges) : void
    {
      //def fileIndex = source.GetSourceSnapshot().FileIndex;
      //mutable resetedMember;
      //mutable resetedMemberParsed;
      //mutable lastRelocationVersion = -1;

      when (!IsDefaultEngine)
      {
        def project = this.Project;

        when (project != null)
        {
          //def relocationRequests = RelocationQueue.GetRelocationRequests(source.RelocationRequestsQueue);
          //
          //foreach (rel in relocationRequests)
          {
            //lastRelocationVersion = rel.SourceVersion;
            //def info = RelocationInfo(changes);
            //def beginLine   = changes; // TODO: использовать локейшон
            //def beginColumn = ;
            //
            //def compileUnit = project.CompileUnits[fileIndex];
            //
            //def needRelocation = match (compileUnit.FindMember(info.Begin.Line, info.Begin.Column))
            //{
            //  | Some(m is ClassMember.Function) =>
            //    def innerLoc = m.BodyInnerLocation;
            //
            //    if (innerLoc.Contains(info.Begin.Line, info.Begin.Column))
            //    {
            //      resetedMemberParsed = m;
            //      assert(resetedMember == null || resetedMember : object == m.Builder);
            //      resetedMember       = m.Builder :> MethodBuilderEx;
            //      // Не делаем релокешон если локешон метода не меняется!
            //      def newLoc =
            //        try { Completion.Relocate(innerLoc, info) }
            //        catch { _ is Completion.RelocationFailedException => Location.Default };
            //      when (resetedMember != null)
            //      {
            //        resetedMember.ResetCodeCache();
            //        AsyncWorker.AddResponse(() => _callback.ClearMethodCompilerMessages(resetedMember));
            //        AddMethodAtFirstCheckQueue(resetedMember); // Add request for typing of relocated method body
            //      }
            //      newLoc != innerLoc
            //    }
            //    else true
            //
            //  | _x => true
            //}
            //
            //def isUpdate = rel.Begin != rel.Old && rel.Begin != rel.New;
            //if (resetedMember == null && isUpdate)
            //{
            //  RequestOnBuildTypesTree();
            //  break;
            //}
            //else when (needRelocation)
            //  compileUnit.TopNamespace.Relocate(info);

            //TODO: Relocate: Regions & ParseCompilerMessages (А надо ли если мы все время получаем ноый CompileUnit?)
          }
        }
      }
    }

    static CollectAndApplyTopDeclarations(source : IIdeSource, compUnit : CompileUnit) : void
    {
      def topDecls       = compUnit.TopDeclarations;
      def decls          = AstUtils.GetAllDeclarations(topDecls);

      def declsAry = decls
        .Where(d => d.name is Splicable.Name && d.name.GetName().context != null)
        .OrderBy(d => d.Name)
        .ToArray();

      //source.Declarations = declsAry;
      AsyncWorker.AddResponse(() => source.SetTopDeclarations(declsAry));
      //source.SetTopDeclarations(declsAry);
    }

    static CollectAndApplyRegions(ideSource : IIdeSource, compUnit : CompileUnit) : void
    {
      def version = compUnit.Source.Version;
      when (ideSource.Version != version)
        return;

      when (compUnit.ParseCompilerMessages.Any(cm => cm.Msg.Contains("parse error")))
        return;

      def regions = RegionsHelper.Collect(compUnit);

      when (ideSource.Version != version)
        return;

      AsyncWorker.AddResponse(() => ideSource.SetRegions(regions, version));
    }

    /// Run by AsyncWorker thread!
    /// Parse CompileUnit. Set CompileUnit to source. Update information about outline regions.
    private UpdateCompileUnit(request : AsyncRequest) : void
    {
      surroundwith (currentAsyncRequest)
      try
      {
        //def timer = Stopwatch.StartNew();
        AsyncWorker.CheckCurrentThreadIsTheAsyncWorker();
        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit..."));
        //Debug.WriteLine($"UpdateCompileUnit 1 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (request.Stop)
        {
          AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is canceled."));
          return;
        }

        def req = request :> UpdateCompileUnitAsyncRequest;
        //RequestOnBuildTypesTree();

        if (req.Changes == null)
          AsyncWorker.AddResponse(() => _callback.TypesTreeCreated());
        else when (_optionsHasBeenRead)
          _ = BeginBuildTypesTree();

        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is finished."));

        /*
        def sourceSnapshot = request.GetSourceSnapshot();
        def ideSource    = request.Source;

        def compUnit = ParseCompileUnit(sourceSnapshot);

        ideSource.CompileUnit = compUnit;

        //Debug.WriteLine($"UpdateCompileUnit 2 $(timer.Elapsed)"); timer.Reset(); timer.Start();
        def isStopingMsg(msg) { msg.Contains("unexpected end of file") || msg.Contains("Newline in constant") }
        def errors = compUnit.ParseCompilerMessages;

        when (errors.Any(cm => isStopingMsg(cm.Msg)))
        {
          // The user does type non closed bracket or quote. The AST is be in incorrect state.
          // We should report errors and stop processing the CompileUnit.
          AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit aborted (file in inconsistent state)."));
          return;
        }

        CollectAndApplyTopDeclarations(ideSource, compUnit);

        //Debug.WriteLine($"UpdateCompileUnit 3 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (request.Stop)
          return;

        CollectAndApplyRegions(ideSource, compUnit);

        //Debug.WriteLine($"UpdateCompileUnit 5 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (!request.Stop && !IsDefaultEngine)
        {
          def isNeedRebuildTypesTree(engine, source) : bool
          {
            // Сравненивает старый и новый CompileUnit, и если их структура не совпадает (т.е. были
            // добавлены, удалены, изменены методы), запустить парсинг дерева типов.
            // Парсинг дерева типов так же запускается если оно не существует к этому моменту.

            //TODO: VladD2: Возможно в IsStructureOfCompileUnitChanged нужно передавать еще
            // старое значение CompileUnit-а (то что было в source.CompileUnit до его обновления).
            // Иначе сравнение будет всегда происходить с CompileUnit-ом полученым при построении
            // дерева типов и это может привести черт знает к чему. В общем нужно продумать стратегию
            // проверки изменения структуры CompileUnit-а!!!
            def isNeedBuildTypesTree =
              if (engine.IsProjectAvailable)
                engine.Project.IsStructureOfCompileUnitChanged(source)
              else
                true;
            isNeedBuildTypesTree
          }

          if (isNeedRebuildTypesTree(this, ideSource))
            RequestOnBuildTypesTree();
          else lock (ideSource.RelocationRequestsQueue)
          {
            try
            {
              when (ideSource.RelocationRequestsQueue.Count == 0)
                return;

              when (ideSource.RelocationRequestsQueue.Last().SourceVersion != sourceSnapshot.Version)
                return;

              TryRelocate(ideSource);
            }
            catch
            {
            | _ is Completion.RelocationFailedException => RequestOnBuildTypesTree();
            | _ => throw;
            }
          }
        }
        */

        //Debug.WriteLine($"UpdateCompileUnit 6 $(timer.Elapsed)"); timer.Reset(); timer.Start();
      }
      catch
      { | e is CompilationAbortedException =>
          def msg = $"The update CompileUnit operation aborted at: $(e.Message)";
          throw CompilationAbortedException(msg, e);
      }
      finally
      {
        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is complete."));
        request.MarkAsCompleted();
      }
    }

    internal ParseCompileUnit(source : SourceSnapshot) : CompileUnit
    {
      RestoreManagerClassInstance();
      _isCompileUnit = true;
      def currentMessages = _currentMessages;
      try
      {
        _namespaces.Clear();

        _currentMessages = List();
        _decls           = [];
        def parseResult  =
          try Parser.Parse(source)
          catch
          { | e =>
              Message.Error(Location(source, 0), $"Exception: [$(e.GetType().Name)] $(e.Message)");
              ParseResult([])
          };
        def loc          = Location(source, 0, source.OriginalText.Length);
        def commentLocs  = parseResult.CommentLocations;
        def openLoc      = loc.FromStart();
        def closeLoc     = openLoc.FromEnd();
        def insideEnv    = match (_decls.Find(_ is Decl.Using))
                           { | Some(Decl.Using as u) => u.AfterEnv | _ => CoreEnv };
        def topNs        = Decl.Namespace(loc, _decls.Rev(), [], [], CoreEnv, insideEnv, source, openLoc, openLoc, closeLoc, parseResult.TopDeclarations);

        assert(_namespaces.Count == 0);

        // Данная функция подключает полученный список TopDeclaration-ов в пространсва имен к которым
        // они пренадлежат.
        // Go through namespaces for each file.

        def addTypes(ns, topDeclarations) : void
        {
          def getNsDeclList(ns, acc = List())
          {
            acc.Add(ns);

            foreach (subNs is Decl.Namespace in ns.Decls)
              _ = getNsDeclList(subNs, acc);

            acc
          }

          def typesGroupedByNs = topDeclarations.GroupBy(
                d => match (d.TryGetEnv()) { | Some(env) => env | _ => null });
          def nsDeclList = getNsDeclList(ns).NToList();
          def join = nsDeclList.Join(typesGroupedByNs,
                nsDecl => nsDecl.InsideEnv,
                group  => group.Key,
                x      => x);
          foreach ((nsDecl, group) in join)
            foreach (topDeclaration in group)
              nsDecl.Decls ::= Decl.Type(topDeclaration.Location, topDeclaration);
        }

        addTypes(topNs, parseResult.TopDeclarations);

        def cu = CompileUnit(topNs, parseResult.TopDeclarations.Rev(), parseResult.Regions.Rev(), _currentMessages.UpCastToArray(), source, commentLocs);

        foreach (msg in cu.ParseCompilerMessages)
          msg.CompileUnit = cu;

        AsyncWorker.AddResponse(() => _callback.SetCompilerMessageForCompileUnit(cu));
        //_callback.SetCompilerMessageForCompileUnit(cu);

        cu
      }
      finally
      {
        _isCompileUnit = false;

        //when (currentMessages != null && _currentMessages.Count > 0)
        //  currentMessages.AddRange(_currentMessages);

        _currentMessages = currentMessages;
        _decls           = [];
      }
    }
  } // end class Engine
} // end of Nemerle.Completion2 namespace
