using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Utility;
using Nemerle.Compiler.Utils;
using Nemerle.Compiler.Utils.Async;
using Nemerle.Surround;

[assembly: DefineSurround("currentAsyncRequest", false,
                          _currentAsyncRequest = request,
                          {
                            _currentAsyncRequest = null;
                          })]


namespace Nemerle.Completion2
{
  using MethodBuilderEx = Factories.IntelliSenseModeMethodBuilder;

  internal partial class Engine
  {
    public LastEditTime : DateTime { get; private set; }

    public BeginUpdateCompileUnit(ideSource : IIdeSource, changes : IChanges) : AsyncRequest
    {
      LastEditTime = DateTime.Now;
      def request = UpdateCompileUnitAsyncRequest(this, ideSource, changes, UpdateCompileUnit);
      AsyncWorker.AddWork(request);
      request
    }

    /// Run by AsyncWorker thread! Parse CompileUnit. Set CompileUnit to source. Update information about outline regions.
    private UpdateCompileUnit(request : AsyncRequest) : void
    {
      surroundwith (currentAsyncRequest)
      try
      {
        def timer = Stopwatch.StartNew();
        AsyncWorker.CheckCurrentThreadIsTheAsyncWorker();
        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit..."));
        //Debug.WriteLine($"UpdateCompileUnit 1 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (request.Stop)
        {
          AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is canceled."));
          return;
        }

        def req = request :> UpdateCompileUnitAsyncRequest;

        unless (TryRelacate(req.Changes))
        {
          if (req.Changes == null)
            AsyncWorker.AddResponse(() => _callback.TypesTreeCreated());
          else when (_optionsHasBeenRead)
            _ = BeginBuildTypesTree();
        }

        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is finished."));

        /*
        def sourceSnapshot = request.GetSourceSnapshot();
        def ideSource    = request.Source;

        def compUnit = ParseCompileUnit(sourceSnapshot);

        ideSource.CompileUnit = compUnit;

        //Debug.WriteLine($"UpdateCompileUnit 2 $(timer.Elapsed)"); timer.Reset(); timer.Start();
        def isStopingMsg(msg) { msg.Contains("unexpected end of file") || msg.Contains("Newline in constant") }
        def errors = compUnit.ParseCompilerMessages;

        when (errors.Any(cm => isStopingMsg(cm.Msg)))
        {
          // The user does type non closed bracket or quote. The AST is be in incorrect state.
          // We should report errors and stop processing the CompileUnit.
          AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit aborted (file in inconsistent state)."));
          return;
        }

        CollectAndApplyTopDeclarations(ideSource, compUnit);

        //Debug.WriteLine($"UpdateCompileUnit 3 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (request.Stop)
          return;

        CollectAndApplyRegions(ideSource, compUnit);

        //Debug.WriteLine($"UpdateCompileUnit 5 $(timer.Elapsed)"); timer.Reset(); timer.Start();

        when (!request.Stop && !IsDefaultEngine)
        {
          def isNeedRebuildTypesTree(engine, source) : bool
          {
            // Сравненивает старый и новый CompileUnit, и если их структура не совпадает (т.е. были
            // добавлены, удалены, изменены методы), запустить парсинг дерева типов.
            // Парсинг дерева типов так же запускается если оно не существует к этому моменту.

            //TODO: VladD2: Возможно в IsStructureOfCompileUnitChanged нужно передавать еще
            // старое значение CompileUnit-а (то что было в source.CompileUnit до его обновления).
            // Иначе сравнение будет всегда происходить с CompileUnit-ом полученым при построении
            // дерева типов и это может привести черт знает к чему. В общем нужно продумать стратегию
            // проверки изменения структуры CompileUnit-а!!!
            def isNeedBuildTypesTree =
              if (engine.IsProjectAvailable)
                engine.Project.IsStructureOfCompileUnitChanged(source)
              else
                true;
            isNeedBuildTypesTree
          }

          if (isNeedRebuildTypesTree(this, ideSource))
            RequestOnBuildTypesTree();
          else lock (ideSource.RelocationRequestsQueue)
          {
            try
            {
              when (ideSource.RelocationRequestsQueue.Count == 0)
                return;

              when (ideSource.RelocationRequestsQueue.Last().SourceVersion != sourceSnapshot.Version)
                return;

              TryRelocate(ideSource);
            }
            catch
            {
            | _ is Completion.RelocationFailedException => RequestOnBuildTypesTree();
            | _ => throw;
            }
          }
        }
        */

        //Debug.WriteLine($"UpdateCompileUnit 6 $(timer.Elapsed)"); timer.Reset(); timer.Start();
      }
      catch
      { | e is CompilationAbortedException =>
          def msg = $"The update CompileUnit operation aborted at: $(e.Message)";
          throw CompilationAbortedException(msg, e);
      }
      finally
      {
        AsyncWorker.AddResponse(() => _callback.SetStatusText("Update compile unit is complete."));
        request.MarkAsCompleted();
      }
    }

    TryRelacate(changes : IChanges) : bool
    {
      when (IsDefaultEngine)
        return false;

      when (changes == null)
        return false;

      def project = this.Project;

      when (project == null)
        return false;

      def fileIndex   = changes.Before.FileIndex;
      def compileUnit = project.CompileUnits[fileIndex];

      when (compileUnit == null)
        return false;

      match (changes)
      {
        | single  is ISingleChanges   => TryRelacate(changes, single.Change, project, compileUnit)
        | multile is IMultipleChanges =>
          foreach (change in multile.ReversedChanges)
            unless (TryRelacate(changes, change, project, compileUnit))
              return false;
          true

        | _ => assert2(false); true
      }
    }

    TryRelacate(changes : IChanges, change : Change, project : Project, compileUnit : CompileUnit) : bool
    {
      def relocate(changes : IChanges, project : Project, compileUnit : CompileUnit)
      {
        def info = RelocationInfo(changes);
        compileUnit.TopNamespace.Relocate(info);
        def typeBuilders = project.NamespaceTree.GetTypeBuilders();
        foreach (typeBuilder in typeBuilders)
          (typeBuilder : ISupportRelocation).RelocateImpl(info);
      }

      // Релокация поддерживается для двух случаев: 1) изменились только пробелы; 2) изменения происходят внутри тела метода.
      def beforeSource = changes.Before;
      def afterSource  = changes.After;
      def beforeText   = beforeSource.Text;
      def afterText    = afterSource.Text;
      def oldSpan      = change.OldSpan;
      def oldEndPos    = oldSpan.EndPos;

      def onlySpacesChanged = ret :
      {
        for (mutable i = oldSpan.StartPos; i < oldEndPos; i++)
          unless (char.IsWhiteSpace(beforeText[i]))
            ret(false);

        def newEndPos = change.NewSpan.EndPos;

        for (mutable i = change.NewSpan.StartPos; i < newEndPos; i++)
          unless (char.IsWhiteSpace(afterText[i]))
            ret(false);
        true
      };

      when (onlySpacesChanged)
      {
        relocate(changes, project, compileUnit);
        return true;
      }

      def at   = Location(beforeSource, oldSpan.StartPos, oldSpan.EndPos);
      def declOpt = compileUnit.FindMember(at);

      def canRetypeOnlyMemberBody =
        match (declOpt)
        {
          | Some(m is ClassMember.Function) =>
            def loc = m.BodyInnerLocation;
            if (loc.IsNestedIn(at) && loc.StartPos > at.StartPos && loc.EndPos < at.EndPos)
            {
              def resetedMember = m.Builder :> MethodBuilderEx;
              if (resetedMember == null)
                false
              else
              {
                resetedMember.ResetCodeCache();
                AsyncWorker.AddResponse(() => _callback.ClearMethodCompilerMessages(resetedMember));
                AddMethodAtFirstCheckQueue(resetedMember); // Add request for typing of relocated method body
                true
              }
            }
            else
              false

          | _x => false
        };

      when (canRetypeOnlyMemberBody)
        relocate(changes, project, compileUnit);

      canRetypeOnlyMemberBody
    }

    static CollectAndApplyTopDeclarations(source : IIdeSource, compUnit : CompileUnit) : void
    {
      def topDecls       = compUnit.TopDeclarations;
      def decls          = AstUtils.GetAllDeclarations(topDecls);

      def declsAry = decls
        .Where(d => d.name is Splicable.Name && d.name.GetName().context != null)
        .OrderBy(d => d.Name)
        .ToArray();

      //source.Declarations = declsAry;
      AsyncWorker.AddResponse(() => source.SetTopDeclarations(declsAry));
      //source.SetTopDeclarations(declsAry);
    }

    static CollectAndApplyRegions(ideSource : IIdeSource, compUnit : CompileUnit) : void
    {
      def version = compUnit.Source.Version;
      when (ideSource.Version != version)
        return;

      when (compUnit.ParseCompilerMessages.Any(cm => cm.Msg.Contains("parse error")))
        return;

      def regions = RegionsHelper.Collect(compUnit);

      when (ideSource.Version != version)
        return;

      AsyncWorker.AddResponse(() => ideSource.SetRegions(regions, version));
    }

    internal ParseCompileUnit(source : SourceSnapshot) : CompileUnit
    {
      RestoreManagerClassInstance();
      _isCompileUnit = true;
      def currentMessages = _currentMessages;
      try
      {
        _namespaces.Clear();

        _currentMessages = List();
        _decls           = [];
        def parseResult  =
          try Parser.Parse(source)
          catch
          { | e =>
              Message.Error(Location(source, 0), $"Exception: [$(e.GetType().Name)] $(e.Message)");
              ParseResult([])
          };
        def loc          = Location(source, 0, source.OriginalText.Length);
        def commentLocs  = parseResult.CommentLocations;
        def openLoc      = loc.FromStart();
        def closeLoc     = openLoc.FromEnd();
        def insideEnv    = match (_decls.Find(_ is Decl.Using))
                           { | Some(Decl.Using as u) => u.AfterEnv | _ => CoreEnv };
        def topNs        = Decl.Namespace(loc, _decls.Rev(), [], [], CoreEnv, insideEnv, source, openLoc, openLoc, closeLoc, parseResult.TopDeclarations);

        assert(_namespaces.Count == 0);

        // Данная функция подключает полученный список TopDeclaration-ов в пространсва имен к которым
        // они пренадлежат.
        // Go through namespaces for each file.

        def addTypes(ns, topDeclarations) : void
        {
          def getNsDeclList(ns, acc = List())
          {
            acc.Add(ns);

            foreach (subNs is Decl.Namespace in ns.Decls)
              _ = getNsDeclList(subNs, acc);

            acc
          }

          def typesGroupedByNs = topDeclarations.GroupBy(
                d => match (d.TryGetEnv()) { | Some(env) => env | _ => null });
          def nsDeclList = getNsDeclList(ns).NToList();
          def join = nsDeclList.Join(typesGroupedByNs,
                nsDecl => nsDecl.InsideEnv,
                group  => group.Key,
                x      => x);
          foreach ((nsDecl, group) in join)
            foreach (topDeclaration in group)
              nsDecl.Decls ::= Decl.Type(topDeclaration.Location, topDeclaration);
        }

        addTypes(topNs, parseResult.TopDeclarations);

        def cu = CompileUnit(topNs, parseResult.TopDeclarations.Rev(), parseResult.Regions.Rev(), _currentMessages.UpCastToArray(), source, commentLocs);

        foreach (msg in cu.ParseCompilerMessages)
          msg.CompileUnit = cu;

        AsyncWorker.AddResponse(() => _callback.SetCompilerMessageForCompileUnit(cu));
        //_callback.SetCompilerMessageForCompileUnit(cu);

        cu
      }
      finally
      {
        _isCompileUnit = false;

        //when (currentMessages != null && _currentMessages.Count > 0)
        //  currentMessages.AddRange(_currentMessages);

        _currentMessages = currentMessages;
        _decls           = [];
      }
    }
  } // end class Engine
} // end of Nemerle.Completion2 namespace
