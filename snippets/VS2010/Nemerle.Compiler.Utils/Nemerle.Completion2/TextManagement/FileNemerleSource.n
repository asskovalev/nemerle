using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Utility;

using NFile = Nemerle.Compiler.File;

namespace Nemerle.Completion2
{
  public class FileNemerleSource : IIdeSource, IDisposable
  {
    public CompileUnit : CompileUnit    { get; set; }
    public HasView     : bool           { get { false } }
    public FileIndex   : int            { get _file.Id; }
    public Version     : int            { get; private set; }
    private _source    : SourceSnapshot { get; private set; }
    private _file      : NFile          { get; private set; }
    private _watcher   : FileSystemWatcher;

    public this(baseVersion : int, path : string)
    {
      Version = baseVersion - 1; // -1 because UpdateSourceSnapshot will increment the Version
      _file = FileUtils.GetFile(path);
      UpdateSourceSnapshot();
      def dir = Path.GetDirectoryName(path);
      def name = Path.GetFileName(path);
      def watcher = FileSystemWatcher(dir, name);
      watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime;
      watcher.Changed += FileNemerleSource_ChangedOrCreated;
      watcher.EnableRaisingEvents = true;
      _watcher = watcher;

      Debug.WriteLine($"FileNemerleSource created Version=$Version $path");
    }

    FileNemerleSource_ChangedOrCreated(_sender : object, _e : FileSystemEventArgs) : void
    {
      UpdateSourceSnapshot();
        //Engine.RequestOnReloadProject();
    }

    public UpdateSourceSnapshot() : void
    {
      Version++;
      def file = _file;
      if (file.IsSourceFileAvailable)
        _source = FileUtils.FileSourceSnapshot(file, version=Version, isGenerated=false);
      else
        _source = FakeSourceSnapshot(file);
    }

    /// !!! Coordinats is zero based!
    private ToPositionImpl(
      code          : string,
      startLine     : int,
      startChar     : int,
      startPosition : int,
      line          : int,
      @char         : int
    )
      : int
    {
      assert(line > startLine || line == startLine && @char >= startChar);
      mutable i       = startPosition;
      def peek() { if (i < code.Length) code[i] else '\0' }
      def next() { def ch = peek(); i++; ch }
      def skip() { i++; }

      def scanLines(ln, stopLn)
      {
        def ch = next();
        def x = i; def code = code; _ = x;

        if (ln == stopLn)
        {
          def chOffset = if (startLine == stopLn) @char - startChar else @char;

          if (chOffset + i - 1 == code.Length && chOffset == 0)
            i - 1
          else if (chOffset + i - 1 > code.Length)
            throw ArgumentOutOfRangeException("char");
          else if (code.IndexOfAny(array['\r', '\n'], i - 1, chOffset) >= 0)
            throw ArgumentOutOfRangeException("char");
          else
            i + chOffset - 1
        }
        else match (ch)
        {
          | '\r' =>
            when (peek() == '\n')
              skip();
           scanLines(ln + 1, stopLn)

          | '\n' => scanLines(ln + 1, stopLn)
          | '\0' => throw ArgumentOutOfRangeException("line or char");
          | _    => scanLines(ln, stopLn)
        }
      }

      def result = scanLines(startLine, line);
      assert(result >= 0 && result <= code.Length);
      result
    }


    public GetSourceSnapshot() : SourceSnapshot
    {
      when (_source.IsFake && _file.IsSourceFileAvailable)
        _source = FileUtils.FileSourceSnapshot(_file, version=1, isGenerated=false);
      _source
    }

    public SetMethodsTypeHighlighting(_bodyLocation : Location, _typeLocations : List[Location], _sourceVersion : int) : void
    {
    }

    public SetTypeHighlighting(_list : IList[Location], _sourceVersion : int) : void
    {
    }

    /// Return string corresponding to given coordinates.
    /// Coordinats is 1 based.
    public GetRegion(lineStart : int, colStart : int, lineEnd : int, colEnd : int) : string
    {
      def source   = _source;
      def startPos = source.LineColumnToPosition(LineColumn(lineStart, colStart));
      def endPos   = source.LineColumnToPosition(LineColumn(lineEnd, colEnd));
      source.OriginalText.Substring(startPos, endPos - startPos);
    }

    /// Return string corresponding to given location.
    /// Coordinats is 1 based.
    public GetRegion(location : Location) : string
    {
      location.GetText()
    }

    /// Return string corresponding to given line.
    /// Coordinate is 1 based.
    public GetLine(line : int) : string
    {
      _source.GetSourceLine(line).GetText()
    }

    public SetRegions(_regions : IList[RegionInfo], _sourceVersion : int) : void { }
    public SetTopDeclarations(_topDeclarations : array[TopDeclaration]) : void { }

    public override ToString() : string
    {
      "FileNemerleSource: " + _source
    }

    public Dispose() :void
    {
      _watcher.Dispose();
    }
  } // class SimpleSourceTextManager
} // namespace Nemerle.Completion2
