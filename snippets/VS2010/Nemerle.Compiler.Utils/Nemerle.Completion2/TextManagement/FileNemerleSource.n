using System;
using System.Collections.Generic;
using System.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Utility;

namespace Nemerle.Completion2
{
  public class FileNemerleSource : IIdeSource
  {
    public Source      : SourceSnapshot { get; private set; }
    public CompileUnit : CompileUnit { get; set; }
    public HasView     : bool { get { false } }

    public this(fileIndex : int)
    {
      Source = FileUtils.GetSource(fileIndex);
    }

    public override ToString() : string
    {
      "FileNemerleSource: " + Source
    }

    /// !!! Coordinats is zero based!
    private ToPositionImpl(
      code          : string,
      startLine     : int,
      startChar     : int,
      startPosition : int,
      line          : int,
      @char         : int
    )
      : int
    {
      assert(line > startLine || line == startLine && @char >= startChar);
      mutable i       = startPosition;
      def peek() { if (i < code.Length) code[i] else '\0' }
      def next() { def ch = peek(); i++; ch }
      def skip() { i++; }

      def scanLines(ln, stopLn)
      {
        def ch = next();
        def x = i; def code = code; _ = x;

        if (ln == stopLn)
        {
          def chOffset = if (startLine == stopLn) @char - startChar else @char;

          if (chOffset + i - 1 == code.Length && chOffset == 0)
            i - 1
          else if (chOffset + i - 1 > code.Length)
            throw ArgumentOutOfRangeException("char");
          else if (code.IndexOfAny(array['\r', '\n'], i - 1, chOffset) >= 0)
            throw ArgumentOutOfRangeException("char");
          else
            i + chOffset - 1
        }
        else match (ch)
        {
          | '\r' =>
            when (peek() == '\n')
              skip();
           scanLines(ln + 1, stopLn)

          | '\n' => scanLines(ln + 1, stopLn)
          | '\0' => throw ArgumentOutOfRangeException("line or char");
          | _    => scanLines(ln, stopLn)
        }
      }

      def result = scanLines(startLine, line);
      assert(result >= 0 && result <= code.Length);
      result
    }


    public GetSourceSnapshot() : SourceSnapshot { Source }

    public GetText() : string
    {
      try
      {
        def filePath = Location.GetFileName(_fileIndex);
        def fullPath = Path.GetFullPath(filePath);
        File.ReadAllText(fullPath, Text.UTF8Encoding(true, true))
      }
      catch { | _ is FileNotFoundException => "" }
    }

    public SetMethodsTypeHighlighting(_bodyLocation : Location, _typeLocations : List[Location], _sourceVersion : int) : void
    {
    }

    public SetTypeHighlighting(_list : IList[Location], _sourceVersion : int) : void
    {
    }

    /// Return string corresponding to given coordinates.
    /// Coordinats is 1 based.
    public GetRegion(lineStart : int, colStart : int, lineEnd : int, colEnd : int) : string
    {
      def source   = Source;
      def startPos = source.LineColumnToPosition(LineColumn(lineStart, colStart));
      def endPos   = source.LineColumnToPosition(LineColumn(lineEnd, colEnd));
      source.OriginalText.Substring(startPos, endPos - startPos);
    }

    /// Return string corresponding to given location.
    /// Coordinats is 1 based.
    public GetRegion(location : Location) : string
    {
      location.GetText()
    }

    /// Return string corresponding to given line.
    /// Coordinate is 1 based.
    public GetLine(line : int) : string
    {
      Source.GetSourceLine(line).GetText()
    }

    /// Convert location (line/char coordinate) to position (character offset).
    /// Coordinats is 1 based.
    public GetPositionOfLineIndex(line : int, @char : int) : int
    {
      Source.LineColumnToPosition(LineColumn(line, @char))
    }

    /// Return coordinate corresponding to given position.
    /// "position" is zero based. Returning coordinate is 1 based.
    public GetLineIndexOfPosition(position : int) : LineColumn
    {
      Source.PositionToLineColumn(position)
    }

    public LineCount : int
    {
      // phantom: didn't think whether this implementation right or wrong
      // (guess wrong, but i needed to implement it in some way for use)
      [Obsolete("TODO: implement LineCount right")]
      get
      {
        def code = GetText();
        mutable i = 0;
        mutable position = -1;
        def eols = array['\r', '\n'];
        do
        {
          position = code.IndexOfAny(eols, position + 2);
          i++;
        }
        while (position >= 0);

        --i;
        i
      }
    }

    public LockWrite()       : void { }
    public UnlockWrite()     : void { }
    public LockReadWrite()   : void { }
    public UnlocReadkWrite() : void { }

    public SetRegions(_regions : IList[RegionInfo], _sourceVersion : int) : void { }
    public SetTopDeclarations(_topDeclarations : array[TopDeclaration]) : void { }
    public RelocationRequestsQueue : List[RelocationRequest] { get { null } }
    //public GetRelocationRequests() : array[RelocationRequest] { array(0) }
  } // class SimpleSourceTextManager
} // namespace Nemerle.Completion2
