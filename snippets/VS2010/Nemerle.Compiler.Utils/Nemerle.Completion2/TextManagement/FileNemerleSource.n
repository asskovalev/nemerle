using System;
using System.Collections.Generic;
using System.IO;

using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Utility;

namespace Nemerle.Completion2
{
  public class FileNemerleSource : IIdeSource
  {
    public Source      : SourceSnapshot { get; private set; }
    public CompileUnit : CompileUnit    { get; set; }
    public HasView     : bool           { get { false } }
    public FileIndex   : int            { get Source.FileIndex; }
    public Version     : int            { get Source.Version; }

    public this(path : string)
    {
      Source = FileUtils.FileSourceSnapshot(FileUtils.GetFile(path), version=1, isGenerated=false);
    }

    public override ToString() : string
    {
      "FileNemerleSource: " + Source
    }

    /// !!! Coordinats is zero based!
    private ToPositionImpl(
      code          : string,
      startLine     : int,
      startChar     : int,
      startPosition : int,
      line          : int,
      @char         : int
    )
      : int
    {
      assert(line > startLine || line == startLine && @char >= startChar);
      mutable i       = startPosition;
      def peek() { if (i < code.Length) code[i] else '\0' }
      def next() { def ch = peek(); i++; ch }
      def skip() { i++; }

      def scanLines(ln, stopLn)
      {
        def ch = next();
        def x = i; def code = code; _ = x;

        if (ln == stopLn)
        {
          def chOffset = if (startLine == stopLn) @char - startChar else @char;

          if (chOffset + i - 1 == code.Length && chOffset == 0)
            i - 1
          else if (chOffset + i - 1 > code.Length)
            throw ArgumentOutOfRangeException("char");
          else if (code.IndexOfAny(array['\r', '\n'], i - 1, chOffset) >= 0)
            throw ArgumentOutOfRangeException("char");
          else
            i + chOffset - 1
        }
        else match (ch)
        {
          | '\r' =>
            when (peek() == '\n')
              skip();
           scanLines(ln + 1, stopLn)

          | '\n' => scanLines(ln + 1, stopLn)
          | '\0' => throw ArgumentOutOfRangeException("line or char");
          | _    => scanLines(ln, stopLn)
        }
      }

      def result = scanLines(startLine, line);
      assert(result >= 0 && result <= code.Length);
      result
    }


    public GetSourceSnapshot() : SourceSnapshot { Source }

    public SetMethodsTypeHighlighting(_bodyLocation : Location, _typeLocations : List[Location], _sourceVersion : int) : void
    {
    }

    public SetTypeHighlighting(_list : IList[Location], _sourceVersion : int) : void
    {
    }

    /// Return string corresponding to given coordinates.
    /// Coordinats is 1 based.
    public GetRegion(lineStart : int, colStart : int, lineEnd : int, colEnd : int) : string
    {
      def source   = Source;
      def startPos = source.LineColumnToPosition(LineColumn(lineStart, colStart));
      def endPos   = source.LineColumnToPosition(LineColumn(lineEnd, colEnd));
      source.OriginalText.Substring(startPos, endPos - startPos);
    }

    /// Return string corresponding to given location.
    /// Coordinats is 1 based.
    public GetRegion(location : Location) : string
    {
      location.GetText()
    }

    /// Return string corresponding to given line.
    /// Coordinate is 1 based.
    public GetLine(line : int) : string
    {
      Source.GetSourceLine(line).GetText()
    }

    public SetRegions(_regions : IList[RegionInfo], _sourceVersion : int) : void { }
    public SetTopDeclarations(_topDeclarations : array[TopDeclaration]) : void { }
    public RelocationRequestsQueue : List[RelocationRequest] { get { null } }
    //public GetRelocationRequests() : array[RelocationRequest] { array(0) }
  } // class SimpleSourceTextManager
} // namespace Nemerle.Completion2
