using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Completion2;
using Nemerle.Imperative;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;

using System.Text;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;
using SCG   = System.Collections.Generic;
using NC = Nemerle.Compiler;

namespace Nemerle.Compiler.Utils
{
  public module Utils
  {
    InvariantCultureCompareInfo : CompareInfo = CultureInfo.InvariantCulture.CompareInfo;

    public Contains(this loc : Location, at : Location) : bool
    {
      when (loc.FileIndex != at.FileIndex)
        return false;

      loc.Contains(at.StartPos)
    }

    [DebuggerNonUserCode]
    public static ToVsOutputStringFormat(this loc : Location) : string
    {
      mutable res = $"$(loc.File)($(loc.Line),$(loc.Column)";

      when (loc.EndLine > loc.Line || loc.EndLine == loc.Line && loc.EndColumn > loc.Column)
        res += $",$(loc.EndLine),$(loc.EndColumn)";

      res + "): ";
    }

    public MaxOrDefault[T](this seq : Seq[T], isGreater : T * T -> bool) : T
    {
      mutable x;

      foreach (elem when isGreater(elem, x) in seq)
        x = elem;

      x
    }

    public GetLastImplementedMembersOfInterface(typeBulder : TypeBuilder, interfaceType : FixedType.Class)
      : option[IMember]
    {
      def res1 = GetImplementedMembersOfInterface(typeBulder, interfaceType,
                    m => !m.Location.IsGenerated);
      def res2 = res1.MaxOrDefault((x, y) => y == null || x.Location.EndPos > y.Location.EndPos);

      if (res2 == null) None() else Some(res2)
    }

    public GetImplementedMembersOfInterface(
      typeBulder    : TypeBuilder,
      interfaceType : FixedType.Class,
      predicate     : IMember -> bool
    )
      : Seq[IMember]
    {
      def mems = typeBulder.GetMembers(BindingFlags.Public | BindingFlags.NonPublic
                                     | BindingFlags.DeclaredOnly | BindingFlags.Instance);
      def isImplemented(member : IMember) : bool
      {
        | m is MethodBuilder   => m.ImplementedMethods.Exists((t, _) => t.Equals(interfaceType))
        | p is PropertyBuilder => isImplemented(p.GetGetter()) || isImplemented(p.GetSetter())
        | _                    => false
      }

      mems.FilterLazy(x => predicate(x) && isImplemented(x))
    }

    public GenerateMemberImplementation(
      writer         : IO.TextWriter,
      fileIndex      : int,
      ty             : FixedType.Class,
      member         : IMember,
      explicit       : bool,
      accessMods     : string,
      implName       : string,
      generateXmlDoc : bool,
    ) : void
    {
      def generator = InterfaceMemberImplSourceGenerator(fileIndex, writer, ty, explicit, accessMods, implName, generateXmlDoc);

      match (member)
      {
        | method is IMethod   =>  generator.WriteMethodDeclaration(method);
        | prop   is IProperty =>  generator.WritePropertyDeclaration(prop);
        | _ => throw ArgumentException($"Unsupported member type ($member.GetType().Name)", "member");
      }
    }

    /// Finds the innermost top level construction (namespace, class,
    /// using, attribute) located at fileIndex, line, and col.
    public FindMember([NotNull] this typeDecl : TopDeclaration, at : Location) : option[DeclarationBase]
    {
      def members = typeDecl.GetMembers();

      match (members.Find(member => member.Location.Contains(at)))
      {
        | Some(ClassMember.TypeDeclaration(td)) =>
          match (FindMember(td, at))
          {
            | Some as result => result
            | None           => Some(td)
          }

        | Some(Property(getter = Some(acc))) when acc.Location.Contains(at)
        | Some(Property(setter = Some(acc))) when acc.Location.Contains(at) => Some(acc)
        // TODO: VladD2: Сделать тоже самое для инициализаторов полей.
        | Some(Field as field) when field.BodyLocation.Contains(at) =>
          def flgs = if (field.Attributes %&& NemerleModifiers.Static) BindingFlags.Static else BindingFlags.Instance;
          def methods = if (field.Builder == null) []
                        else field.Builder.DeclaringType.GetMethods(flgs %|  BindingFlags.DeclaredOnly %| BindingFlags.NonPublic);
          def name = "_N_field_initialiser__" + field.Name;
          match (methods.Find(m => m.Name == name))
          {
            | Some(methodBuilder is MethodBuilder) => Some(methodBuilder.Ast)
            | _                                    => Some(field)
          }

        | Some(member) => Some(member)
        | _ => None()
      }
    }

    public Partition[T](this source : Seq[T], predicate : T -> bool) : SCG.List[T] * SCG.List[T]
    {
      def list1 = SCG.List();
      def list2 = SCG.List();

      foreach (x in source)
        if (predicate(x))
          list1.Add(x);
        else
          list2.Add(x);

      (list1, list2)
    }

    public MoveToFirst[T](this source : SCG.List[T], item : T) : void
    {
      while (source.Remove(item))
        ();
      source.Insert(0, item);
    }

    public AddAtFirst[T](this source : SCG.List[T], item : T) : void
    {
      source.Insert(0, item)
    }

    public Enqueue[T](this source : SCG.List[T], item : T) : void
    {
      source.Add(item)
    }

    public Dequeue[T](this source : SCG.List[T]) : T
    {
      def result = source[0];
      source.RemoveAt(0);
      result
    }

    public GetLast[T](this source : SCG.IList[T]) : T
    {
      source[source.Count - 1]
    }

    public GetLast[T](this source : array[T]) : T
    {
      source[source.Length - 1]
    }

    public GetLast[T](this source : SCG.IList[T], aDefault : T) : T
    {
      if (source.Count > 0) source[source.Count - 1]
      else                  aDefault
    }

    public GetLast[T](this source : array[T], aDefault : T) : T
    {
      if (source.Length > 0) source[source.Length - 1]
      else                   aDefault
    }

    // For debug purposes, brief output
    public Brief(this output : string, maximalLength : int = 100) : string
    {
      def ellipsis = "...";
      def s = output.Replace('\n', ' ');
      if (s.Length > maximalLength)
        s.Substring(0, maximalLength - ellipsis.Length) + ellipsis;
      else
        s
    }

    /// Fast find index of substing.
    public OrdinalIndexOf(this source : string, value : string, startIndex : int) : int
    {
      InvariantCultureCompareInfo.IndexOf(source, value,
        startIndex, CompareOptions.Ordinal);
    }

    public StartsWithIgnoreCase(this source : string, value : string) : bool
    {
      InvariantCultureCompareInfo.IsPrefix(source, value, CompareOptions.IgnoreCase)
    }

    public OrdinalStartsWith(this source : string, value : string) : bool
    {
      source.StartsWith(value, StringComparison.Ordinal)
    }

    public IsNullOrEmpty(this value : string) : bool
    {
      if (value == null) true else value.Length == 0
    }

    public IsNullOrEmpty[T](this value : list[T]) : bool
    {
      if (value == null) true else value.IsEmpty
    }

    public IsVariantType(sysType : Type) : bool
    {
      sysType.GetCustomAttributes(Const.VariantType, false).Length == 1
    }

    public IsVariantOptionType(sysType : Type) : bool
    {
      sysType.GetCustomAttributes(Const.VariantOptionType, false).Length == 1
    }

    public GetGlyphIndex(this typeInfoCache : NamespaceTree.TypeInfoCache) : GlyphType
    {
      // TypeInfo loaded or parsed
      | Cached(ty)               => ty.GetTydecl().GetGlyphIndex()
      // ambiguous TypeInfo loaded or parsed
      | CachedAmbiguous          => GlyphType.Snippet
      // TypeInfo of external type not yet loaded
      | NotLoaded                => assert2(false); assert(false);
      | NotLoadedList(_extTypes) => GlyphType.Snippet
      | NamespaceReference       => GlyphType.Namespace
      | MacroCall                => GlyphType.Macro
      | No                       => GlyphType.Snippet
    }

    public GetGlyphIndex(this typeDecl : Typedtree.TypeDeclaration) : GlyphType
    {
        | Class         => GlyphType.Class
        | Alias(ty)     => ty.TypeInfo.GetTydecl().GetGlyphIndex()
        | Interface     => GlyphType.Interface
        | Variant       => GlyphType.Variant //{ members : list [TypeInfo]; }
        | VariantOption => GlyphType.VariantOption
        | Enum          => GlyphType.Enum
    }

    public GetTypeKindName(this typeDecl : Typedtree.TypeDeclaration) : string
    {
      | Class         => "class "
      | Alias(ty)     => "alias: " + GetTypeKindName(ty.TypeInfo.GetTydecl())
      | Interface     => "interface "
      | Variant       => "variant "
      | VariantOption => "variant option "
      | Enum          => "enum "
    }

    public static IsSpecialConstraint(ty : PExpr) : bool
    {
    | PExpr.Ref(name) =>
      match (name.Id)
      {
      | "new"
      | "class"
      | "struct"
      | "+"
      | "-" => true
      | _   => false
      }
    | _   => false
    }

    public static ToMethodDefinitionString(this t : TypeVar) : string
    {
      | FixedType.Fun(parms, to) =>
        def parmsStr = match (parms)
        {
          | FixedType.Tuple as tuple => tuple.args.Map(ToDisplayString).ToString(", ")
          | _                    => parms.ToDisplayString()
        }

        "(" + (if (parmsStr == "void") "" else parmsStr) + ") : " + to.ToDisplayString()

      | _ => " : " + t.ToDisplayString()
    }

    public static GetFullName(this member: IMember) : string
    {
      match (member)
      {
        | ti is NC.TypeInfo => ti.FullName
        | _ =>
          if (member.DeclaringType is null)
            member.Name
          else
            member.DeclaringType.FullName + "." + member.Name
      }
    }

    public static ToDisplayString(this t : TypeVar) : string
    {
      ToDisplayString(t, SCG.Dictionary())
    }

    public static ToDisplayString(this t : FixedType) : string
    {
      ToDisplayString(t, SCG.Dictionary())
    }

    public static GetNameFromType (t : TypeVar) : string
    {
      GetNameFromType(t, SCG.Dictionary())
    }

    public static GetNameFromType (t : FixedType) : string
    {
      GetNameFromType(t, SCG.Dictionary())
    }

    private static ToDisplayString(t : TypeVar, types : SCG.Dictionary[FixedType,int]) : string
    {
      GetNameFromType(t, types);
    }

    private static ToDisplayString(t : FixedType, types : SCG.Dictionary[FixedType,int]) : string
    {
      GetNameFromType(t, types);
    }

    private static GetNameFromType (t : TypeVar, types : SCG.Dictionary[FixedType,int]) : string
    {
      match (t)
      {
        | mType is FixedType => GetNameFromType(mType, types)
        | x =>
          match (x.UpperBound)
          {
            | Some(mType) => GetNameFromType(mType, types)
            | _ => "<unknown>"
          }
      }
    }

    private static GetNameFromType (t : FixedType, types : SCG.Dictionary[FixedType,int]) : string
    {
      when (types.ContainsKey(t))
        return "<error: cyclic type found>";

      types.Add(t, 0);

      try
      {
        match (t)
        {
          | Class as c =>
            mutable name = Completion.ReplaceSpecialName(c.tycon.FrameworkTypeName);

            when (c.args.Length > 0)
            {
              name += "[";

              foreach (x in c.args)
                name += GetNameFromType (x, types) + ", ";

              name = name.Trim(',', ' ') + "]";
            }
            name

          | StaticTypeVarRef as r => r.tyvar.Name
          | Fun as f =>
            def fromTy = f.from.Fix();
            def toTy   = f.to.Fix();
            if (fromTy : object == t || toTy : object == t)
              "<error: cyclic type found>"
            else
              GetNameFromType(fromTy) + " -> " + GetNameFromType(toTy, types)

          | Tuple as tuple => tuple.args.Map(ToDisplayString(_, types)).ToString(" * ")
          | Array as a => "array[" + GetNameFromType(a.t.Fix(), types) + "]"
          | Void => "void"
          | Ref as rf => "ref " + GetNameFromType (rf.t.Fix(), types)
          | Out as ut => "out " + GetNameFromType (ut.t.Fix(), types)
          | Intersection(types) => $"one of $types"
        }
      }
      finally { _ = types.Remove(t); }
    }

    public static GetGlyphIndex(this member : IMember) : int
    {
      def glyphType = match (member.MemberKind)
      {
        | Field                 => GlyphType.Field
        | Method                => GlyphType.Method
        | Constructor           => GlyphType.Class
        | Property              => GlyphType.Property
        | TypeInfo | NestedType => GlyphType.Class
        | Event                 => GlyphType.Event
        | _                     => GlyphType.Class
      };

      glyphType :> int;
    }

    public GetMemberByLocation(this typeBuilder : TypeBuilder, at : Location) : IMember
    {
      def find(members : list[IMember])
      {
      | member :: tail =>

        match (member)
        {
        | tb is TypeBuilder     =>

          if (tb.Location.Contains(at))
            GetMemberByLocation(tb, at) ?? tb;
          else
            find(tail)

        //| pb is PropertyBuilder =>

        //  def mb = find([pb.GetGetter(), pb.GetSetter()]);

        //  if (mb != null)
        //    mb
        //  else if (!pb.IsGenerated && pb.Location.Contains(fileIndex, at))
        //    pb
        //  else
        //    null

        //| fb is FieldBuilder    =>

        //  def name = fb.Ast.name;

        //  if (!name.Location.IsGenerated && name.Location.Contains(fileIndex, at))
        //    fb
        //  else
        //    find(tail);

        | mb is MethodBuilder   =>

          if (!mb.IsGenerated &&
              (mb.Location.Contains(at) || mb.BodyLocation.Contains(at)))
            mb
          else
            find(tail)

        | mb is MemberBuilder
          when !mb.IsGenerated && mb.Location.Contains(at) =>

            mb

        | _ => find(tail)
        }

      | [] => null
      }

      def members = typeBuilder.GetMembers(
        BindingFlags.Static %| BindingFlags.Instance  %|
        BindingFlags.Public %| BindingFlags.NonPublic %|
        BindingFlags.DeclaredOnly);

      find(members)
    }

    public GetLocalPath(this asm : Assembly) : string
    {
       Uri(asm.CodeBase).LocalPath;
    }

    public IndexOf ['a] (this l : list ['a], a : 'a) : int
    {
      def loop(l, a, idx)
      {
        match (l)
        {
        | h :: t  =>
          if (h.Equals (a))
            idx
          else
            loop (t, a, idx + 1)
        | [] => -1
        }
      }

      loop(l, a, 0)
    }

    public FindIndexOf ['a] (this l : list ['a], pred : 'a -> bool) : int
    {
      def loop(l, pred, idx)
      {
        match (l)
        {
        | h :: t  =>
          if (pred(h))
            idx
          else
            loop (t, pred, idx + 1)
        | [] => -1
        }
      }

      loop(l, pred, 0)
    }

    /// The 'lst' must be ordered. This function test only first and last elements.
    public static OrderedContains[TT](this lst : list[TT], at : Location) : bool
      where TT : Located
    {
      Debug.Assert(lst.IsOrdered((x, y) => x.Location.CompareTo(y.Location) > 0));

      if (lst.IsEmpty)
        false
      else
        (lst.Head.Location + lst.Last.Location).Contains(at)
    }

    public ReadAllTokens(this lex : Lexer) : array[Token]
    {
      def lst = SCG.List();
      def safeGetToken(lexer : Lexer)
      {
        try { lexer.GetToken() }
        catch
        {
          | _ is Lexer.Error => Token.EndOfFile(); // Ignore lexer errors (VladD2: maybe add warning?)
          | _ => throw
        }
      }
      def scan(tok : Token)
      {
        | EndOfFile | null => lst
        | _                => lst.Add(tok); scan(safeGetToken(lex));
      }

      def result = scan(safeGetToken(lex)).ToArray();
      result
    }

    public Clear[T](this ary : array[T]) : void
    {
      Array.Clear(ary, 0, ary.Length);
    }

    /// Retrieve full namespace path and names of all outer types.
    /// list[string] - namespace path.
    /// list[string * int]:
    ///      string - name of type
    ///      int - type parameters count.
    public static MakeFullName(this topDecl : TopDeclaration) : list[string] * list[string * int]
    {
      def makeFullName(topDecl : TopDeclaration, typeInfs)
      {
        def typeParamCount = topDecl.typarms.tyvars.Length;

        if (topDecl.DefinedIn == null)
          if (topDecl.name is Splicable.Name)
            (topDecl.PName.context.CurrentNamespace.FullName, ((topDecl.Name, typeParamCount) :: typeInfs))
          else
            ([""],                                            ((topDecl.Name, typeParamCount) :: typeInfs))
        else
          makeFullName(topDecl.DefinedIn, (topDecl.Name, typeParamCount) :: typeInfs)
      }

      makeFullName(topDecl, [])
    }

    public static GetLocation(obj : object) : Location
    {
      | obj is Located => obj.Location
      | obj is IMember => obj.Location
      | obj is Decl    => obj.Location
      | _              => Location.Default;
    }

    /// Return nonoverlapping list of 'overlappingRanges'
    public RemoveOverlapping[TValue, TPoint](
      overlappingRanges : list[TValue * TPoint * TPoint],
      increment : TPoint -> TPoint,
      decrement : TPoint -> TPoint
    )
      : list[TValue * TPoint * TPoint]
      where TPoint: System.IComparable[TPoint]
    {
      RemoveOverlapping(overlappingRanges, _.CompareTo(_), increment, decrement)
    }

    /// Return nonoverlapping list of 'overlappingRanges'
    public RemoveOverlapping[TValue, TPoint](
      overlappingRanges : list[TValue * TPoint * TPoint],
      compare : TPoint * TPoint -> int,
      increment : TPoint -> TPoint,
      decrement : TPoint -> TPoint
    )
      : list[TValue * TPoint * TPoint]
    {
      def (entries, _) = overlappingRanges.FoldLeft(([], 0), fun((value, start, end), (acc, i))
        { ((value, start, 1, i) :: (value, increment(end), 0, i) :: acc, i + 1) });

      //WriteLine(entries);

      def entriesSorted = entries.Sort(fun((_, p1, _, i1), (_, p2, _, i2))
        { def res = compare(p1, p2); if (res == 0) i1 - i2 else res } );

      //WriteLine(entriesSorted);

      def result = entriesSorted.FoldLeft(([(Nemerle.Extensions.DefaultValue(TValue), -1)], []),
        fun((value, pos, start, i), (stack, res))
        {
          def newStack = if (start != 0) (value, i) :: stack else stack.Remove(value, i);
          def (topValue, topIndex) = newStack.Head;
          (newStack, (topValue, topIndex, pos) :: res)
        });

      def ranges = result[1].Rev();

      //WriteLine(ranges);

      def rangesFiltered = ranges.Tail.FoldLeft((ranges.Head, []),
        fun((_, nextIndex, nextPos) as next, ((value, index, pos) as curr, acc))
        {
          assert(compare(pos, nextPos) <= 0); assert(index >= 0); assert(nextIndex >= -1);
          if (index == nextIndex) (curr, acc)
          else (next, if (compare(pos, nextPos) == 0) acc
                      else (value, pos, decrement(nextPos)) :: acc)
        });

      def result = rangesFiltered[1].Rev();

      result
    }

    public static CallForAllRelated[T](this mb : MemberBuilder, func : MethodBuilder -> T) : T
    {
      match (mb.Related)
      {
        | RefTo.Method(method) => func(method)
        | RefTo.Methods(methods) => methods.Map(func).Head;
        | RefTo.Type(t) => t.GetMethods().Map(m => func(m :> MethodBuilder)).Head;
        | RefTo.Types(ts) => ts.Fold([], (t, acc) => t.GetMethods() + acc).Map(m => func(m :> MethodBuilder)).Head;
        | RefTo.None => Nemerle.Extensions.DefaultValue(T);
      }
    }

    public static GetAllRelated(this mb : MemberBuilder) : SCG.IEnumerable[MethodBuilder]
    {
      match (mb.Related)
      {
        | RefTo.Method(method) => yield method;
        | RefTo.Methods(methods) =>
          foreach (method in methods)
            yield method;

        | RefTo.Type(t) =>
          foreach (method :> MethodBuilder in t.GetMethods())
            yield method;

        | RefTo.Types(ts) =>
          foreach (t in ts)
            foreach (method :> MethodBuilder in t.GetMethods())
              yield method;

        | RefTo.None => ()
      }
    }

    public Exclude[T1, T2](this seq1 : Seq[T1], seq2 : Seq[T2], cmp : T1 * T2 -> bool) : Seq[T1]
    {
      def res = SCG.List();

      foreach (e when !seq2.Exists(cmp(e, _)) in seq1)
        res.Add(e);

      res
    }

    /// <summary>
    /// Return the column position of 1st non whitespace character on line
    /// </summary>
    /// <param name="line"></param>
    /// <returns></returns>
    public ScanToNonWhitespaceChar(text : string) : int
    {
        mutable i = 0;

        while (i < text.Length && char.IsWhiteSpace(text[i]))
            i++;
        i
    }

    /// <summary>
    /// Convert a user visible position back to char position in the buffer.
    /// This is the opposite of ColumnToVisiblePosition. In this case the
    /// visible position was off the end of the line, it just returns the
    /// column position at the end of the line.
    /// </summary>
    public VisiblePositionToColumn(text : string, tabsize : int, visiblePosition : int) : int
    {
        mutable visible = 0;
        mutable i       = 0;

        for (; i < text.Length; i++)
        {
          def ch = text[i];
          def step =
            if (ch == '\t' && visible % tabsize == 0)
              tabsize
            else
              1;

          visible += step;

          when (visible > visiblePosition)
            return i;
        }

        i
    }

    /// <summary>
    /// Return the column position that the user will see given the current
    /// tab size setting.  This is the opposite of VisiblePositionToColumn
    /// </summary>
    public ColumnToVisiblePosition(text : string, col : int, tabsize : int) : int
    {
        when (col <= 0)
          return 0;

        mutable visible = 0;

        for (mutable i = 0; i < col && i < text.Length; i++)
        {
            def ch = text[i];
            def step =
              if (ch == '\t')
                tabsize - visible % tabsize;
              else
                1;

            visible += step;
        }

        visible
    }

    /// <summary>
    /// Return the Visible Position of line indent that the user will see given the current
    /// tab size setting.
    /// </summary>
    public CalcIndentVisiblePosition(text : string, tabSize : int) : int
    {
      def indentLen = ScanToNonWhitespaceChar(text);

      when (indentLen <= 0)
        return 0;

      ColumnToVisiblePosition(text, indentLen, tabSize)
    }

    public MakeIndentString(indentCount : int, insertTabs : bool, indentSize : int, tabSize : int) : string
    {
      if (insertTabs)
      {
        def allIndentSize = indentCount   * indentSize;
        def spacesNeeded  = allIndentSize % tabSize;
        def tabsNeeded    = allIndentSize / tabSize;

        if (tabsNeeded > 0 && spacesNeeded > 0)
        {
          def sb = StringBuilder(tabsNeeded + spacesNeeded);
          _ = sb.Append('\t', tabsNeeded);
          _ = sb.Append(' ', spacesNeeded);
          sb.ToString()
        }
        else if (tabsNeeded > 0)
          string('\t', tabsNeeded)
        else if (spacesNeeded > 0)
          string(' ', spacesNeeded)
        else
          ""
      }
      else
        string(' ', indentSize * indentCount);
    }

    /// <summary>
    /// Replace one tub indent to indent which conform specified indent. Replacment do in all lines of text.
    /// </summary>
    public NormalizeIndent(text : string, insertTabs : bool, indentSize : int, tabSize : int) : StringBuilder
    {
      def skipToEol(text : string, mutable i : int, result : StringBuilder) : int
      {
        if (i >= text.Length)
          i
        else
        {
          def ch = text[i];

          _ = result.Append(ch);

          if (ch == '\n')
            i + 1
          else if (ch == '\r')
            if (i + 1 < text.Length && text[i + 1] == '\n')
              skipToEol(text, i + 1, result)
            else
              i + 1
          else
            skipToEol(text, i + 1, result)
        }
      }
      def result = StringBuilder();

      for (mutable i = 0; i < text.Length; i = skipToEol(text, i + 1, result))
      {
        def ch = text[i]; // first char of line

        when (ch == '\t')
        {
          mutable tubCount = 1;

          for (i++; i < text.Length && text[i] == '\t'; i++) // calc and skip tabs
            tubCount++;

          _ = result.Append(MakeIndentString(tubCount, insertTabs, indentSize, tabSize));
         i--;
        }
      }

      result
    }

    public ParseMethodBody(this method : MethodBuilder) : PExpr
    {
      def bodyLocation = method.BodyLocation;
      def engine       = method.Manager :> Engine;
      def lexer        = Lexer(engine, bodyLocation.Source, bodyLocation);
      lexer.Keywords   = engine.CoreEnv.Keywords;
      engine.ParseMethodBody(method, lexer).expr;
    }

    public Visit[T](this expr : PExpr, visiter : PExpr -> ValueOption[T]) : ValueOption[T]
    {
      when (expr == null)
        return VNone();

      def visitSplicable(splicable : Splicable) : ValueOption[T]
      {
        if (splicable is Expression as e)
          Visit(e.expr, visiter)
        else
          VNone()
      }
      def visitParameter(p : PParameter) : ValueOption[T]
      {
          def res0 = visitSplicable(p.name);
          when (res0.IsSome)
            return res0;

          def res1 = Visit(p.Type, visiter);
          when (res1.IsSome)
            return res1;

          when (p.DefaultValue is Some(defaultValue))
          {
            def res2 = Visit(defaultValue, visiter);
            when (res2.IsSome)
              return res2;
          }

          VNone()

      }
      def visite1(current : PExpr, arg1 : PExpr) : ValueOption[T]
      {
        def res = visiter(current);
        if (res.IsSome)
          res
        else
          Visit(arg1, visiter)
      }
      def visite2(current : PExpr, arg1 : PExpr, arg2 : PExpr) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        def res1 = Visit(arg1, visiter);
        when (res1.IsSome)
          return res1;

        Visit(arg2, visiter)
      }
      def visiteX(restArgs : list[PExpr]) : ValueOption[T]
      {
        foreach (arg in restArgs)
        {
          def res = Visit(arg, visiter);
          when (res.IsSome)
            return res;
        }

        VNone()
      }
      def visite0X(current : PExpr, restArgs : list[PExpr]) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        foreach (arg in restArgs)
        {
          def res = Visit(arg, visiter);
          when (res.IsSome)
            return res;
        }

        VNone()
      }
      def visite1X(current : PExpr, arg1 : PExpr, restArgs : list[PExpr]) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        def res1 = visiter(arg1);
        when (res1.IsSome)
          return res1;

        foreach (arg in restArgs)
        {
          def res = Visit(arg, visiter);
          when (res.IsSome)
            return res;
        }

        VNone()
      }
      def visite1S(current : PExpr, arg1 : PExpr, splicable : Splicable) : ValueOption[T]
      {
          if (splicable is Expression as e)
            visite2(current, arg1, e.expr)
          else
            visite1(current, arg1)
      }
      def visite1Opt(current : PExpr, arg1Opt : option[PExpr]) : ValueOption[T]
      {
        def res = visiter(current);
        if (res.IsSome)
          res
        else if (arg1Opt is Some(arg1))
          Visit(arg1, visiter)
        else
          VNone()
      }
      def syntaxElement(syntaxElement : SyntaxElement) : ValueOption[T]
      {
        | Expression       (body) => Visit(body, visiter)
        | TType            (body) => Visit(body, visiter)
        | Function         (body : FunctionDecl) => Visit(body.body, visiter)
        | RawToken
        | ClassMember
        | TypeBuilder
        | FieldBuilder
        | MethodBuilder
        | PropertyBuilder
        | EventBuilder
        | ParameterBuilder => VNone()
        | Parameter        (p) => visitParameter(p)
        | PMatchCase       (case : Parsetree.PMatchCase) =>
          def res0 = visiteX(case.patterns);
          when (res0.IsSome)
            return res0;

          def res1 = Visit(case.body, visiter);
          when (res1.IsSome)
            return res1;

          VNone()

        }
      def visite0E(current : PExpr, se : SyntaxElement) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        syntaxElement(se)
      }
      def visiteFunc(f : FunctionDecl) : ValueOption[T]
      {
        def h = f.header;

        def res1 = Visit(h.ReturnType, visiter);
        when (res1.IsSome)
          return res1;

        def res2 = visitSplicable(h.SplicableName);
        when (res2.IsSome)
          return res2;

        foreach (x in h.TypeParameters.tyvars)
        {
          def res3 = visitSplicable(x);
          when (res3.IsSome)
            return res3;
        }

        foreach (c in h.TypeParameters.constraints)
        {
          def res4 = Visit(c.Expression, visiter);
          when (res4.IsSome)
            return res4;
        }

        def res5 = Visit(f.body, visiter);
        when (res5.IsSome)
          return res5;

        VNone()
      }
      def visiteFunc0(current : PExpr, funs : list[FunctionDecl]) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        foreach (f in funs)
        {
          def res = visiteFunc(f);
          when (res.IsSome)
            return res;
        }

        VNone()
      }
      def visiteFunc1(current : PExpr, f : FunctionDecl) : ValueOption[T]
      {
        def res0 = visiter(current);
        when (res0.IsSome)
          return res0;

        def res = visiteFunc(f);
        when (res.IsSome)
          return res;

        VNone()
      }
      match (expr)
      {
        | Wildcard                               as node => Visit(node, visiter)
        | Void                                   as node => Visit(node, visiter)
        | Ref                                    as node => Visit(node, visiter)
        | Is               (pat, ty)             as node => visite2(node, pat, ty)
        | As               (pat, name)           as node => visite1S(node, pat, name)
        | Where            (name, fields)        as node => visite2(node, name, fields)
        | Sequence         (body)                as node => visite0X(node, body)
        | Member           (obj, member)         as node => visite1S(node, obj, member)
        | Call             (func, parms)         as node => visite1X(node, func, parms)
        | GenericSpecifier (func, generic_parms) as node => visite1X(node, func, generic_parms)
        | ListLiteral      (elements)            as node => visite0X(node, elements)
        | Assign           (target, source)      as node => visite2(node, target, source)
        | DefMutable       (name, val)           as node => visite2(node, name, val)
        | Define           (pattern, val)        as node => visite2(node, pattern, val)
        | Throw            (exn)                 as node => visite1(node, exn)
        | TryFinally       (body, handler)       as node => visite2(node, body, handler)
        | Literal                                as node => Visit(node, visiter)
        | This                                   as node => Visit(node, visiter)
        | Base             (ty)                  as node => visite1Opt(node, ty)
        | Typeof           (ty)                  as node => visite1(node, ty)
        | TypeConversion   (expr, ty)            as node => visite2(node, expr, ty)
        | TypeEnforcement  (expr, ty)            as node => visite2(node, expr, ty)
        | Tuple            (args)                as node => visite0X(node, args)
        | Array            (rank, args)          as node => visite2(node, rank, args)
        | EmptyArray       (sizes)               as node => visite0X(node, sizes)
        | Indexer          (obj, args)           as node => visite1X(node, obj, args)
        | ParmByRef        (parm)                as node => visite1(node, parm)
        | ParmOut          (parm)                as node => visite1(node, parm)
        | Error                                  as node => Visit(node, visiter)
        | Quoted           (body)                as node => visite0E(node, body)
        | Spliced          (body)                as node => visite1(node, body)
        | ToComplete                             as node => Visit(node, visiter)
        | Ellipsis         (body)                as node => visite1(node, body)
        | Typed                                  as node => Visit(node, visiter)
        | TypedPattern                           as node => Visit(node, visiter)
        | TypedType                              as node => Visit(node, visiter)
        | DefFunctions     (funs)                as node => visiteFunc0(node, funs);
        | Lambda           (decl)                as node => visiteFunc1(node, decl);
        | Try              (body, cases)         as node =>
          def res0 = visiter(node);
          when (res0.IsSome)
            return res0;

          def res1 = Visit(body, visiter);
          when (res1.IsSome)
            return res1;

          foreach (case in cases)
          {
            | Catch(exn, exn_ty, handler) =>
              def res2 = visitSplicable(exn);
              when (res2.IsSome)
                return res2;

              def res3 = Visit(exn_ty, visiter);
              when (res3.IsSome)
                return res3;

              def res4 = Visit(handler, visiter);
              when (res4.IsSome)
                return res4;

            | Filter   (exn : Splicable, exn_ty : PExpr, filter : PExpr, handler : PExpr) =>
              def res2 = visitSplicable(exn);
              when (res2.IsSome)
                return res2;

              def res3 = Visit(exn_ty, visiter);
              when (res3.IsSome)
                return res3;

              def res4 = Visit(filter, visiter);
              when (res4.IsSome)
                return res4;

              def res5 = Visit(handler, visiter);
              when (res5.IsSome)
                return res5;

            | Ellipsis(body) =>
              def res2 = Visit(body, visiter);
              when (res2.IsSome)
                return res2;
          }

          VNone()

        | MacroCall        (_, _, parms) as node =>
          def res0 = visiter(node);
          when (res0.IsSome)
            return res0;

          foreach (p in parms)
          {
            def res = syntaxElement(p);
            when (res.IsSome)
              return res;
          }

          VNone()

        | Match            (expr, cases, _) as node =>
          def res0 = visiter(node);
          when (res0.IsSome)
            return res0;

          def res1 = Visit(expr, visiter);
          when (res1.IsSome)
            return res1;

          foreach (case in cases)
          {
            def res2 = visiteX(case.patterns);
            when (res2.IsSome)
              return res2;

            def res3 = Visit(case.body, visiter);
            when (res3.IsSome)
              return res3;
          }

          VNone()

        | _ => assert(false)
      }
    }
  } // End of Utils module
} // End of namespace